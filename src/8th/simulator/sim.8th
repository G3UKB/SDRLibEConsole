(* 
	sim.8th
 
 A simulating server which looks like SDRLibEConnector
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

false var, stress
\ needs debug/trace
\ needs debug/trace-crash
\ needs debug/nicer

\ Sockets and addresses
{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket var, cmd_socket
{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket var, d1_socket
{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket var, d2_socket
{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket var, d3_socket

: cmd_port 10010 ;
: d1_port 10011 ;
: d2_port 10012 ;
: d3_port 10013 ;

: cmd_addr "127.0.0.1" cmd_port net:getaddrinfo ;
: d1_addr "127.0.0.1" d1_port net:getaddrinfo ;	
: d2_addr "127.0.0.1" d2_port net:getaddrinfo ;	
: d3_addr "127.0.0.1" d3_port net:getaddrinfo ;	

\ Bind the command port
cmd_addr cmd_socket @ net:bind

\ State
600 var, disp_width
100 var, disp_period
stress @ #if
	[true,true,true] var, disp_state
#else
 	[false,false,false] var, disp_state
#then

1 var, num_rx

[0.005,0.006,0.007,0.008,0.009,0.010] var, randint_1
[0.005,0.006,0.007,0.008,0.009,0.010] var, randint_2
[0.005,0.006,0.007,0.008,0.009,0.010] var, randint_3

\ Buffers
128 b:new 0x0 b:fill var, cmd_buffer
[] var, disp_buffer_1
[] var, disp_buffer_2
[] var, disp_buffer_3

: put_float	\ buf ix  --
	r@ a:! ;	

: fill_disp_buffers
	disp_buffer_1 @ -73.0 >r ' put_float 0 3840 loop
	disp_buffer_2 @ -110.0 >r ' put_float 0 3840 loop
	disp_buffer_3 @ -130.0 >r ' put_float 0 3840 loop ;

: get_buffer_1
	disp_buffer_1 @ disp_width @ n:1+ >s "f" s:+ pack ;
: get_buffer_2
	disp_buffer_2 @ disp_width @ n:1+ >s "f" s:+ pack ;
: get_buffer_3
	disp_buffer_3 @ disp_width @ n:1+ >s "f" s:+ pack ;
	
\ Client address
\ 19.01
\ var client_addr 
\ var client_port
\ 19.02
var client_x

: client_addr_info
	\ 19.01
	\ client_addr @ client_port @ net:getaddrinfo ;
	\ 19.02
	client_x @ ;
	
\ ========================================
\ Execution words
\ ========================================

: send_resp
	{"resp" : "ACK"} >json cmd_socket @ client_addr_info rot 0 net:sendto 2drop ;

: do_audio_inputs
	{ "inputs" : [{"name" : "device-1" , "api" : "an api" , "index" : 0 , "direction" : 1 , "channels" : 1}, 
	{ "name" : "device-2" , "api" : "an api" , "index" : 0 , "direction" : 1 , "channels" : 1 }]}
	>json cmd_socket @ client_addr_info rot 0 net:sendto 2drop ;
	
: do_audio_outputs
	{ "outputs" : [{ "name" : "device-1" , "api" : "an api" , "index" : 0 , "direction" : 0 , "channels" : 2 },
	{ "name" : "device-2" , "api" : "an api" , "index" : 0 , "direction" : 0 , "channels" : 2 }]}
	>json cmd_socket @ client_addr_info rot 0 net:sendto 2drop ;

: conn_poll drop "poll" log send_resp ;
: conn_cc_out_set_rx_1_freq drop "r1 freq" log send_resp ;
: conn_cc_out_set_rx_2_freq drop "r2 freq" log send_resp ;
: conn_cc_out_set_rx_3_freq drop "r3 freq" log send_resp ;
: conn_cc_out_set_tx_freq drop "tx freq" log send_resp ;
: conn_set_rx_1_mode drop "r1 mode" log send_resp ;
: conn_set_rx_2_mode drop "r2 mode" log send_resp ;
: conn_set_rx_3_mode drop "r3 mode" log send_resp ;
: conn_set_tx_mode drop "tx mode" log send_resp ;
: conn_set_rx_1_filter drop "r1 filter" log send_resp ;
: conn_set_rx_2_filter drop "r2 filter" log send_resp ;
: conn_set_rx_3_filter drop "r3 filter" log send_resp ;
: conn_set_tx_filter drop "tx filter" log send_resp ;
: conn_set_rx_1_agc drop "r1 agc" log send_resp ;
: conn_set_rx_2_agc drop "r2 agc" log send_resp ;
: conn_set_rx_3_agc drop "r3 agc" log send_resp ;
: conn_set_rx_1_gain drop "r1 gain" log send_resp ;
: conn_set_rx_2_gain drop "r2 gain" log send_resp ;
: conn_set_rx_3_gain drop "r3 gain" log send_resp ;
: conn_set_hf_pre drop "HF Pre" log send_resp ;
: conn_set_attn drop "Attn" log send_resp ;
: conn_set_in_rate drop "in rate" log send_resp ;
: conn_set_out_rate drop "out_rate" log send_resp ;
: conn_set_iq_blk_sz drop "iq blk sz" log send_resp ;
: conn_set_mic_blk_sz drop "mic blk sz" log send_resp ;
: conn_set_duplex drop "set duplex" log send_resp ;
: conn_set_fft_size drop "set fft sz" log send_resp ;
: conn_set_window_type drop "set window type" log send_resp ;
: conn_set_av_mode "set av mode" log send_resp ;
: conn_set_display_width 0 a:@ nip >n disp_width lock ! disp_width unlock drop "set disp width:" disp_width @ >s s:+ log send_resp ;
: conn_set_audio_route "audio route" log send_resp ;
: conn_server_start "server start" log send_resp ;
: conn_server_terminate "server term" log send_resp ;
: conn_radio_discover "discover" log send_resp ;
: conn_radio_start "radio start" log send_resp ;
: conn_radio_stop "radio stop" log send_resp ;
: conn_make_wisdom "wisdom" log send_resp ;
: conn_enum_audio_inputs do_audio_inputs "audio inputs" log ;
: conn_enum_audio_outputs do_audio_outputs "audio outputs" log ;
: conn_change_audio_outputs "change audio outputs" log send_resp drop ;
: conn_revert_audio_outputs "revert audio outputs" log send_resp drop ;
: conn_set_disp_period 0 a:@ nip >n disp_period lock ! disp_period unlock drop "set disp period" log send_resp drop ;
: conn_set_disp_state disp_state lock ! disp_state unlock drop "set disp state" log send_resp drop ;
: conn_set_num_rx 0 a:@ nip >n num_rx lock ! num_rx unlock drop "set num rx" log send_resp drop ;

\ Dispatcher table
{
	"poll" : ' conn_poll ,
	"set_rx1_freq" : ' conn_cc_out_set_rx_1_freq ,
	"set_rx2_freq" : ' conn_cc_out_set_rx_2_freq ,
	"set_rx3_freq" : ' conn_cc_out_set_rx_3_freq ,
	"set_tx_freq" : ' conn_cc_out_set_tx_freq ,
	"set_rx1_mode" : ' conn_set_rx_1_mode ,
	"set_rx2_mode" : ' conn_set_rx_2_mode ,
	"set_rx3_mode" : ' conn_set_rx_3_mode ,
	"set_tx_mode" : ' conn_set_tx_mode ,
	"set_rx1_filter" : ' conn_set_rx_1_filter ,
	"set_rx2_filter" : ' conn_set_rx_2_filter ,
	"set_rx3_filter" : ' conn_set_rx_3_filter ,
	"set_tx_filter" : ' conn_set_tx_filter ,
	"set_rx1_agc" : ' conn_set_rx_1_agc ,
	"set_rx2_agc" : ' conn_set_rx_2_agc ,
	"set_rx3_agc" : ' conn_set_rx_3_agc ,
	"set_rx1_gain" : ' conn_set_rx_1_gain ,
	"set_rx2_gain" : ' conn_set_rx_2_gain ,
	"set_rx3_gain" : ' conn_set_rx_3_gain ,
	"set_hf_pre" : ' conn_set_hf_pre ,
	"set_attn" : ' conn_set_attn ,
	"set_in_rate" : ' conn_set_in_rate ,
	"set_out_rate" : ' conn_set_out_rate ,
	"set_iq_blk_sz" : ' conn_set_iq_blk_sz ,
	"set_mic_blk_sz" : ' conn_set_mic_blk_sz ,
	"set_duplex" : ' conn_set_duplex ,
	"set_fft_size" : ' conn_set_fft_size ,
	"set_window_type" : ' conn_set_window_type ,
	"set_av_mode" : ' conn_set_av_mode ,
	"set_display_width" : ' conn_set_display_width ,
	"set_audio_route" : '	conn_set_audio_route ,
	"server_start" : ' conn_server_start ,
	"terminate" : ' conn_server_terminate ,
	"radio_discover" : ' conn_radio_discover ,
	"radio_start" : ' conn_radio_start ,
	"radio_stop" : ' conn_radio_stop ,
	"wisdom" : ' conn_make_wisdom ,
	"enum_inputs" : ' conn_enum_audio_inputs ,
	"enum_outputs" : ' conn_enum_audio_outputs ,
	"change_outputs" : ' conn_change_audio_outputs ,
	"revert_outputs" : ' conn_revert_audio_outputs ,
	"set_disp_period" : ' conn_set_disp_period ,
	"set_disp_state" : ' conn_set_disp_state ,
	"set_num_rx" : ' conn_set_num_rx 
} var, disp_table
	
\ ========================================
\ Reader Task
\ ========================================

\ Read cmd data while not terminated
: cmd_reader
	
		"Waiting for commands..." log
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break else "Bad command!" throw then
				else
					"Got q but then null!" throw
				then
			else
				\ See if we have data
				cmd_socket @ true 500 net:wait if
				\ Read and dispatch
					\ SED in >= 19.02:  \ net buf flags -- net X buf #recv | net null
					cmd_buffer @ 0 net:recvfrom null? not if
						\ 19.01
						\ drop swap client_port ! swap client_addr ! nip
						\ 19.02
						drop swap client_x ! nip
						json>
						dup >kind ns:m n:= not if .s cr "Bad request!" throw then
						"cmd" m:@ swap "params" m:@ >r drop disp_table @ swap m:@ nip r> swap w:exec
					else
						stress @ if
							2drop
						else
							"net:recvfrom returned null!" throw
						then
					then
				else
					drop
				then
			then   
		again
	t:name@ " exiting... [" s:+ depth >s s:+ "]" s:+ log
;

\ ========================================
\ Display Task
\ ========================================

\ Send display data while not terminated
: display_events
	
		"Starting event data.." log
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break else "Bad command!" throw then
				else
					"Got q but then null" throw
				then
			else
				\ Send data as required
				disp_state @ a:rev a:open >r >r >r
				r> if
					\ Display 1
					cmd_socket @ d1_addr get_buffer_1 0 net:sendto 2drop
				then
				r> if
					\ Display 2
					cmd_socket @ d2_addr get_buffer_2 0 net:sendto 2drop
				then
				r> if
					\ Display 3
					cmd_socket @ d3_addr get_buffer_3 0 net:sendto 2drop
				then
				disp_period @ 1000 n:/ sleep
				\ 0.01 sleep
			then
		again
	t:name@ " exiting... [" s:+ depth >s s:+ "]" s:+ log
;

\ Send display data while not terminated with random delays
: display_events_1
	
		"Starting event data.." log
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break else "Bad command!" throw then
				else
					"Got q but then null" throw
				then
			else
				\ Send data as required
				disp_state lock @ 0 a:@ nip disp_state unlock drop
				if
					\ Display 1
					cmd_socket @ d1_addr get_buffer_1 0 net:sendto null? if "Send error" log 2drop else 2drop then
				then
				\ randint_1 @ a:shuffle 0 a:@ nip sleep
				0.003 sleep
			then
		again
	t:name@ " exiting... [" s:+ depth >s s:+ "]" s:+ log
;

: display_events_2
	
		"Starting event data.." log
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break else "Bad command!" throw then
				else
					"Got q but then null" throw
				then
			else
				\ Send data as required
				disp_state lock @ 1 a:@ nip disp_state unlock drop
				if
					\ Display 2
					cmd_socket @ d2_addr get_buffer_2 0 net:sendto null? if "Send error" log 2drop else 2drop then
				then
				\ randint_2 @ a:shuffle 0 a:@ nip sleep
				0.005 sleep
			then
		again
	t:name@ " exiting... [" s:+ depth >s s:+ "]" s:+ log
;

: display_events_3
	
		"Starting event data.." log
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break else "Bad command!" throw then
				else
					"Got q but then null" throw
				then
			else
				\ Send data as required
				disp_state lock @ 2 a:@ nip disp_state unlock drop
				if
					\ Display 3
					cmd_socket @ d3_addr get_buffer_3 0 net:sendto null? if "Send error" log 2drop else 2drop then
				then
				\ randint_3 @ a:shuffle 0 a:@ nip sleep
				0.001 sleep
			then
		again
	t:name@ " exiting... [" s:+ depth >s s:+ "]" s:+ log
;

\ ========================================
\ Main code
\ ========================================

var cmd_task
var display_events_task
var display_events_task_1
var display_events_task_2
var display_events_task_3
	

: app:main

	\ Create display buffer
	fill_disp_buffers
	
	\ Start cmd reader task
	' cmd_reader t:task cmd_task !
	
	\ Start display event task
	stress @ if
		' display_events_1 t:task display_events_task_1 !
		' display_events_2 t:task display_events_task_2 !
		' display_events_3 t:task display_events_task_3 !
	else
		' display_events t:task display_events_task !
	then 
	
	\ Wait for a key
	con:key
	
	\ Terminate
	cmd_task @ "term" t:push
 
	stress @ if
		display_events_task_1 @ "term" t:push
		display_events_task_2 @ "term" t:push
		display_events_task_3 @ "term" t:push
	else
		display_events_task @ "term" t:push
	then
	
	1 sleep
	bye
;