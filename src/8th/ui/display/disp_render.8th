(*
	disp_render.8th
 
  Display renderer for the SDRLibEConsole application
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ Use SDR namespace
ns: sdr

needs stack/utils

\ ===============================================================================
\ Drawing words
var current_spec_id

\ ========================================
\ Helpers
\ Get width of display panel
: w_width		\ -- width
	"inst_data" t:@ get_disp_win_metrics 0 a:@ nip	\	width
;

\ Get height of display panel
: w_height	\ -- height
	"inst_data" t:@ get_disp_win_metrics 1 a:@ nip	\	height
;

\ Get mid-point of the grid in x plane
: mid_grid									\ width -- mid-grid-x
	l_margin n:- r_margin n:-	\ width-margin
	2 n:/ 										\ (width-margin)/2
	l_margin n:+ n:int 				\ ((width-margin)/2) + l_margin
;

\ Get mid top x,y of the grid
: mid_top			\	-- x y
	w_width 		\	width
	mid_grid		\ mid-grid-x
	t_margin		\ top-y
;

\ Get mid-bottom x,y of the grid
: mid_bottom						\ -- x y
	w_width								\	width
	mid_grid							\ mid-grid-x
	w_height b_margin n:-	\ bottom-y
;

\ Get the working height (grid height) of the disply panel
: working_height				\ -- working-height
	w_height t_margin n:- b_margin n:-
;

\ Get the x offset of the low freq side of the filter
: low_x_offset					\ low_filt -- low-x-offset
	"inst_data" t:@ freq_pp n:/ n:int
;

\ Get the x offset of the high freq side of the filter
: high_x_offset					\ high_filt -- high-x-offset
	"inst_data" t:@ freq_pp n:/ n:int
;

\ Get the low/high bounds of the filter
: get_filter_bounds			\ filt -- low-freq high-freq
	filter_lookup 				\ filter-desc
	0 a:@ swap 1 a:@ nip
;

0 enum:
	FILT_LSB
	FILT_USB
	FILT_BOTH
enum;
: do_lsb FILT_LSB ;
: do_usb FILT_USB ;
: do_both FILT_BOTH ;	

\ See if we are LSB, USB or both	
: get_mode_sideband	\ mode -- sidebound
	[ ' do_lsb , ' do_usb , ' do_both , ' do_lsb , ' do_usb , ' do_both , ' do_both , ' do_usb , ' do_both , ' do_lsb , ' do_both , ' do_both ]
	swap caseof
;

\ Common preamble
: get_rect_preamble			\ low-filt high-filt -- a x y r:high_x_offset low_x_offset
	high_x_offset >r
	low_x_offset >r	 			\ r:high_x_offset low_x_offset
	a:new 
	mid_top		
;

\ To the lower sideband of the dial frequency
: get_rect_lsb					\ low-filt high-filt -- rect
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 1 rpick n:-			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	r> r> swap n:- a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

\ To the upper sideband of the dial frequency
: get_rect_usb					\ low-filt high-filt -- rect
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 0 rpick n:+			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	r> r> swap n:- a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

\ To both sidebands
: get_rect_both					\ low-filt high-filt -- rect
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 1 rpick n:-			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	rdrop r> 2 n:* a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

: filter_bounding_rect	\ filter mode -- rect
	\ The bounding rect goes filter low x,y to filter high x,y
	\ The start point depends on the mode
	\ LSB modes to left of the centre freq
	\ USB modes to the right of the centre freq
	\ Other modes centred on the centre freq i.e both sides equally
	get_mode_sideband							\ g filter mode-sideband
	swap get_filter_bounds rot		\ g filter-low filter-high mode-sideband
	[ ' get_rect_lsb , ' get_rect_usb , ' get_rect_both ]
	swap caseof
;

\ ========================================
\ Draw horizontal/vertical label
: draw_label	\ gui idx [text,x,y] --
	nip
	1 a:@ 
	swap 2 a:@
	swap 0 a:@
	nip
	g:draw-text-at
;

\ Add horizontal/vertical grid line to path
: doline \ gui idx fixed_data_itm --
	\ [x-start, y-start, x-stop, y-stop]
	nip											\ gui fixed_data_itm
	0 a:@ swap 1 a:@ 				\ gui x-start fixed_data_itm y-start
	rot swap								\ gui fixed_data_itm x-start y-start
	3 pick swap rot swap		\ gui fixed_data_itm gui x-start y-start
	g:moveto								\ gui fixed_data_itm gui
	swap 2 a:@ swap 3 a:@ 	\ gui gui x-stop fixed_data_itm y-stop
	nip											\ gui gui x-stop y-stop
	g:lineto drop						\ gui
;	

\ Make the grid path
: make_grid_path	\ gui --
	"inst_data" t:@ fixed_data_ref ' doline a:each 
;

\ ========================================
\ PANADAPTER
\ Add next pan node to path
: do_node								\ gui idx pan_data_itm --
	0 a:@ swap 1 a:@ nip 	\ gui idx x y
	rot 0 n:= if					\ gui x y
		g:moveto
	else
		g:lineto
	then
;

\ Close the pan path so it can be filled
: complete_pan_path																\ gui pan-data -- 
	\ Line from the current end point to the bottom right
	swap "inst_data" t:@ get_disp_win_metrics 2dup a:open		\ pan-data gui [width,height] gui width height
	b_margin n:- swap r_margin n:- swap g:lineto			\ pan-data gui [width,height] gui
	\ Line from bottom right to bottom left
	drop 2dup a:open 1 0 poke													\ pan-data gui [width,height] gui 0 height
	b_margin n:- swap l_margin n:+ swap g:lineto			\ pan-data gui [width,height] gui
	\ Line to the first point
	"inst_data" t:@ pan_data_ref														\ pan-data gui [width,height] gui pan-data
	0 a:@ nip 0 a:@ swap 1 a:@ nip										\ pan-data gui [width,height] gui x y
	g:lineto																					\ pan-data gui [width,height] gui
	4drop																							\ --
;

\ Make the pan path
: make_pan_path	\ gui --
	"inst_data" t:@ pan_data_ref ' do_node a:each
	a:len 0 n:> if
		2dup complete_pan_path
	then
	drop
;

\ ========================================
\ WATEFALL

\ Scroll the data up one line
: scroll	\ g img --
 0 null 1 img:scroll drop
;

\ Write next pixel to image
: dopix							\ g img idx spec_data_itm --
	1 a:@ nip 				\ g img col colour
	wf_height n:1- -rot 					\ g img row col colour
	img:pix!	
;

\ Write waterfall line
: wf_update	\ g --
	"inst_data" t:@ dup wf_data_ref \ g disp-id wf-data-ref
	swap get_wf_img						\ g wf-data-ref img
	swap											\ g img wf-data-ref
	' dopix										\ g img wf-data-ref 'dopix
	a:each
	drop
	scroll
;

\ ========================================
\ Draw grid, labels, pan, waterfall
\ Return freq at the current mouse pointer
: get_freq_text	\ gui x y -- gui x y freq
	1 pick l_margin n:- 3 pick "inst_data" t:@ nip x_to_freq >s
;

: draw_all	\ g -- g
	\ Stash the id for this display
	"id" g:m@ dup "disp_name" t:!
	\ and the locked instance data
	radio_ref "inst_data" t:!
	
	\ Common settings
	"gray11" g:fillall
	1 g:line-width
	
	\ Grid lines
	"gray17" g:scolor
	g:clearpath
	g:path
	make_grid_path drop
	g:/path g:stroke
	\ Labels
	"yellow:50" g:scolor
	"inst_data" t:@ h_label_data_ref ' draw_label a:each drop
	"inst_data" t:@ v_label_data_ref ' draw_label a:each
	drop
	\ Panadapter
	g:clearpath
	"green:50" g:scolor
	"green:30" g:fcolor
	g:path
	make_pan_path
	g:/path g:stroke-fill
	\ Waterfall
	st_rad_running@ if
		wf_update
		"inst_data" t:@	dup get_disp_win_metrics a:open nip 	\ g disp-id height
		b_margin n:-																						\ g disp-id start-y
		swap get_wf_img 																				\ g start-y img 
		swap l_margin swap g:image-at
	then
	\ Draw centre freq line
	g:clearpath
	1 g:line-width
	"red" g:scolor
	mid_top g:moveto
	mid_bottom g:lineto
	g:/path g:stroke
	\ Draw filter overlay
	\ Need to get the mid-freq, mode and filter to work out where to put rectangle 
	g:clearpath
	0 g:line-width
	"green:15" g:fcolor
	g:path
	\ Get the bounding rectangle
	"inst_data" t:@ dup get_disp_filt swap get_disp_mode filter_bounding_rect
	a:open g:rect
	g:/path g:stroke-fill
	\ Draw mouse position text
	"orange" g:scolor
	"inst_data" t:@ get_mouse_pos null? not if 
		a:open get_freq_text rot 10 n:+ -rot
		g:draw-text-at 
	else
		2drop
	then
	\ Release lock
	 "disp_name" t:@ radio_ref_unlock
;

\ Restore namespace	
ns: user	