(*
	disp_render.8th
 
  Display renderer for the SDRLibEConsole application
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ Use SDR namespace
ns: sdr

needs stack/utils

\ ========================================
\ DRAWING HELPERS

\ ----------------------------------
\ Get width of display panel
: w_width	SED: -- n
	\ in: 	none
	\ out:	0: n - panel width
	"inst_data" t:@ get_disp_win_metrics 0 a:@ nip ;

\ ----------------------------------
\ Get height of display panel
: w_height	SED: -- n
	\ in: 	none
	\ out:	0: n - panel height
	"inst_data" t:@ get_disp_win_metrics 1 a:@ nip ;

\ ----------------------------------
\ Get mid-point of the grid in x plane
: mid_grid	SED: n -- n
	\ in: 	0: n - panel width
	\ out:	0: n - panel mid pint in x plane
	l_margin n:- r_margin n:-	\ width-margin
	2 n:/ 										\ (width-margin)/2
	l_margin n:+ n:int				\ ((width-margin)/2) + l_margin
;

\ ----------------------------------
\ Get mid top x,y of the grid
: mid_top	SED: g -- g x y
	\ in: 	0: g - gui
	\ out:	0: n - y
	\				1: n - x
	\				2: g - gui
	w_width 		\	width
	mid_grid		\ mid-grid-x
	t_margin		\ top-y
;

\ ----------------------------------
\ Get mid-bottom x,y of the grid
: mid_bottom	SED: g -- g x y
	\ in: 	0: g - gui
	\ out:	0: n - y
	\				1: n - x
	\				2: g - gui
	w_width								\	width
	mid_grid							\ mid-grid-x
	w_height b_margin n:- \ bottom-y
;

\ ========================================
\ FLTER DRAWING

\ ----------------------------------
\ Get the working height (grid height) of the disply panel
: working_height	SED: -- n
	\ in: 	none
	\ out:	0: n - working height
	w_height t_margin n:- b_margin n:-
;

\ ----------------------------------
\ Get the x offset of the low freq side of the filter
: low_x_offset	SED: n -- n
	\ in: 	0: a - low freq
	\ out:	0: a - low-x-offset
	"inst_data" t:@ freq_pp n:/ n:int
;

\ ----------------------------------
\ Get the x offset of the high freq side of the filter
	: high_x_offset	SED: n -- n
	\ in: 	0: a - high freq
	\ out:	0: a - high-x-offset
	"inst_data" t:@ freq_pp n:/ n:int ;

\ ----------------------------------
\ Common preamble
: get_rect_preamble	SED: n n -- a n n
	\ in: 	0: n - high freq
	\				1: n - low freq
	\ out:	0: n - y
	\				1: n - x
	\				2: a - new array
	\	r:		0: n - low_x_offset
	\				1: n - high_x_offset
	high_x_offset >r
	low_x_offset >r	 			\ r:high_x_offset low_x_offset
	a:new 
	mid_top	
;

\ ----------------------------------
\ To the lower sideband of the dial frequency
: get_rect_lsb	SED: n n -- a
	\ in: 	0: a - high freq
	\				1: a - low freq
	\ out:	0: a - rectangle [x,y,width,height]
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 1 rpick n:-			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	r> r> swap n:- a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

\ ----------------------------------
\ To the upper sideband of the dial frequency
: get_rect_usb	SED: n n -- a
	\ in: 	0: a - high freq
	\				1: a - low freq
	\ out:	0: a - rectangle [x,y,width,height]
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 0 rpick n:+			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	r> r> swap n:- a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

\ ----------------------------------
\ To both sidebands
: get_rect_both	SED: n n -- a
	\ in: 	0: a - high freq
	\				1: a - low freq
	\ out:	0: a - rectangle [x,y,width,height]
	get_rect_preamble			\ a x y r:high_x_offset low_x_offset
	swap 1 rpick n:-			\ a y x-orig r:high_x_offset low_x_offset
	rot swap a:push				\ y [x_orig] r:high_x_offset low_x_offset
	swap a:push						\ [x_orig, y_orig] r:high_x_offset low_x_offset
	rdrop r> 2 n:* a:push	\ [x_orig, y_orig, width, ]
	working_height a:push \ [x_orig, y_orig, width, height]
;

\ ----------------------------------
\ Get the low/high bounds of the filter
: get_filter_bounds	SED: n -- n n
	\ in: 	0: n - filter
	\ out:	0: a - low freq
	\				1: a - high freq
	filter_lookup 				\ filter-desc
	0 a:@ swap 1 a:@ nip ;

\ ----------------------------------
\ Filter selection based on mode
0 enum:
	FILT_LSB
	FILT_USB
	FILT_BOTH
enum;

: do_lsb FILT_LSB ;
: do_usb FILT_USB ;
: do_both FILT_BOTH ;	

\ ----------------------------------
\ See if we are LSB, USB or both	
: get_mode_sideband	SED: n -- n
	\ in: 	0: n - mode
	\ out:	0: a - FILT_LSB|FILT_USB|FILT_BOTH
	[ ' do_lsb , ' do_usb , ' do_both , ' do_lsb , ' do_usb , ' do_both , ' do_both , ' do_usb , ' do_both , ' do_lsb , ' do_both , ' do_both ]
	swap caseof ;

\ ----------------------------------
\ Return the bounding rectangle based on mode and filter
: filter_bounding_rect	SED: n n -- a
	\ in: 	0: n - mode
	\				1: n - filter
	\ out:	0: a - rectangle [x,y,width,height]
	\ The bounding rect goes filter low x,y to filter high x,y
	\ The start point depends on the mode
	\ LSB modes to left of the centre freq
	\ USB modes to the right of the centre freq
	\ Other modes centred on the centre freq i.e both sides equally
	get_mode_sideband							\ g filter mode-sideband
	swap get_filter_bounds rot		\ g filter-low filter-high mode-sideband
	[ ' get_rect_lsb , ' get_rect_usb , ' get_rect_both ]
	swap caseof ;

\ ========================================
\ GRID DRAWING

\ ----------------------------------
\ Draw horizontal/vertical label
: draw_label	SED: g n a -- g
	\ in: 	0: a - text descriptor [text,x,y]
	\				1: n - idx
	\				2: g - gui
	\ out:	0: g - gui
	nip
	1 a:@ 
	swap 2 a:@
	swap 0 a:@
	nip
	g:draw-text-at ;

\ ----------------------------------
\ Add horizontal/vertical grid line to path
: doline	SED: g n a -- g
	\ in: 	0: a - fixed_data_itm [x-start, y-start, x-stop, y-stop]
	\				1: n - idx
	\				2: g - gui
	\ out:	0: g - gui
	nip											\ gui fixed_data_itm
	0 a:@ swap 1 a:@ 				\ gui x-start fixed_data_itm y-start
	rot swap								\ gui fixed_data_itm x-start y-start
	3 pick swap rot swap		\ gui fixed_data_itm gui x-start y-start
	g:moveto								\ gui fixed_data_itm gui
	swap 2 a:@ swap 3 a:@ 	\ gui gui x-stop fixed_data_itm y-stop
	nip											\ gui gui x-stop y-stop
	g:lineto drop	;	

\ ----------------------------------
\ Make the grid path
: make_grid_path	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	"inst_data" t:@ fixed_data_ref ' doline a:each drop ;

\ ========================================
\ PANADAPTER DRAWING

\ ----------------------------------
\ Close the pan path so it can be filled
: complete_pan_path	SED: g a --
	\ in: 	0: a - pan_data (whole array)
	\				1: g - gui
	\ out:	none
	\ Line from the current end point to the bottom right
	swap "inst_data" t:@ get_disp_win_metrics 2dup a:open		\ pan-data gui [width,height] gui width height
	b_margin n:- swap r_margin n:- swap g:lineto			\ pan-data gui [width,height] gui
	\ Line from bottom right to bottom left
	drop 2dup a:open 1 0 poke													\ pan-data gui [width,height] gui 0 height
	b_margin n:- swap l_margin n:+ swap g:lineto			\ pan-data gui [width,height] gui
	\ Line to the first point
	"inst_data" t:@ pan_data_ref														\ pan-data gui [width,height] gui pan-data
	0 a:@ nip 0 a:@ swap 1 a:@ nip										\ pan-data gui [width,height] gui x y
	g:lineto																					\ pan-data gui [width,height] gui
	4drop ;

\ ----------------------------------
\ Add next pan node to path
: do_node	SED: g n a -- g
	\ in: 	0: a - pan_data_itm [x,dBm]
	\				1: n - idx
	\				2: g - gui
	\ out:	0: g - gui
	0 a:@ swap 1 a:@ nip 	\ gui idx x y
	rot 0 n:= if					\ gui x y
		\ First item so move to
		g:moveto
	else
		\ Subsequent so add line to
		g:lineto
	then ;

\ ----------------------------------
\ Make the pan path
: make_pan_path	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	"inst_data" t:@ pan_data_ref ' do_node a:each
	a:len 0 n:> if
		2dup complete_pan_path
	then
	drop ;

\ ========================================
\ WATEFALL DRAWING

\ ----------------------------------
\ Scroll the image up one line
\ This creates the waterfall effect as the image moves up the screen
: scroll	SED: g img -- g
	\ in: 	0: img - img
	\				1: g - gui
	\ out:	0: g - gui
 0 null 1 img:scroll drop ;

\ ----------------------------------
\ Write next pixel to image at idx
: dopix	SED: g img n a -- g img
	\ in: 	0: a - pixel data item
	\				1: n - idx
	\ 			2: img - img
	\ 			3: g - gui
	\ out:	0: img - img
	\				1: g - gui
	1 a:@ nip 					\ g img col colour
	wf_height n:1- -rot \ g img row col colour
	img:pix!
;

\ ----------------------------------
\ Write one line of the waterfall according to current data
: wf_update	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	"inst_data" t:@ dup 
	wf_data_ref 							\ g disp-id wf-data-ref
	swap get_wf_img						\ g wf-data-ref img
	swap											\ g img wf-data-ref
	' dopix										\ g img wf-data-ref 'dopix
	a:each
	drop
	scroll
;

\ ===============================================================================
\ TOP LEVEL DRAWING
\ Draw grid, labels, pan, waterfall

\ ----------------------------------
\ Return freq at the current mouse pointer
: get_freq_text	SED: g n n -- g n n s
	\ in: 	0: n - mouse x coord
	\ 			1: n - mouse x coord
	\ 			2: g - gui
	\ out:	0: s - freq as string in MHz
	\				1: n - mouse x coord
	\ 			2: n - mouse x coord
	\ 			3: g - gui
	1 pick l_margin n:- 3 pick "inst_data" t:@ nip x_to_freq >s ;

\ ----------------------------------
\ Draw the grid with dBm and freq labels
: draw_grid	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	"gray17" g:scolor
	g:clearpath
	g:path
	make_grid_path
	g:/path g:stroke
	\ Labels
	"yellow:50" g:scolor
	"inst_data" t:@ h_label_data_ref ' draw_label a:each drop
	"inst_data" t:@ v_label_data_ref ' draw_label a:each
	drop ;

\ ----------------------------------
\ Draw the panadapter display
: draw_pan	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	g:clearpath
	"green:50" g:scolor
	"green:30" g:fcolor
	g:path
	make_pan_path
	g:/path g:stroke-fill ;

\ ----------------------------------
\ Draw the waterfall display
: draw_waterfall	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	st_rad_running@ if
		wf_update
		"inst_data" t:@	dup get_disp_win_metrics a:open nip 	\ g disp-id height
		b_margin n:-																						\ g disp-id start-y
		swap get_wf_img 																				\ g start-y img 
		swap l_margin swap g:image-at
	then ;

\ ----------------------------------
\ Draw centre freq line as a vertical red line
: draw_center_freq_line	SED: g -- g	
	\ in: 	0: g - gui
	\ out:	0: g - gui	
	g:clearpath
	1 g:line-width
	"red" g:scolor
	mid_top g:moveto
	mid_bottom g:lineto
	g:/path g:stroke ;

\ ----------------------------------
\ Draw filter overlay
\ Need to get the mid-freq, mode and filter to work out where to put rectangle 
: draw_filter_overlay	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui
	g:clearpath
	0 g:line-width
	"green:15" g:fcolor
	g:path
	\ Get the bounding rectangle
	"inst_data" t:@ dup get_disp_filt swap get_disp_mode filter_bounding_rect
	a:open g:rect
	g:/path g:stroke-fill ;

\ ----------------------------------
\ Draw the frequency at the current mouse position
: draw_mouse_pos	SED: g -- g
	\ in: 	0: g - gui
	\ out:	0: g - gui
	\ Draw mouse position text
	"orange" g:scolor
	"inst_data" t:@ get_mouse_pos null? not if 
		a:open get_freq_text rot 10 n:+ -rot
		g:draw-text-at 
	else
		2drop
	then ;

\ ========================================
\ Render all display components
: draw_all	SED: g --
	\ in: 	0: g - gui
	\ out:	none
	
	\ Save the display name for this instance
	"id" g:m@ dup "disp_name" t:!
	
	\ Lock and save the instance data
	radio_ref "inst_data" t:!
	
	\ Common settings
	"gray11" g:fillall
	1 g:line-width
	
	\ Draw the display components
	draw_grid
	draw_pan
	draw_waterfall
	draw_center_freq_line
	draw_filter_overlay
	draw_mouse_pos
	
	\ Release lock
	 "disp_name" t:@ radio_ref_unlock ;

\ ========================================
\ Restore namespace	
ns: user	