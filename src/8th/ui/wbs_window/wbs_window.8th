(*
	wbs_window.8th
 
  Wide-band scope window for the DynamicSDR application
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ============================================================================

\ Define our SDR namespace
ns: sdr

\ ========================================
\ WBS window
{
	"kind" : "win",
	"title" : "Dynamic SDR - Wide Bandscope",
	"visible" : false,
	"bg" : "gray10",
	"resize-corner" : 20,
	"wide" : 1024,
	"high" : 160,
	"center" : true,
	"ontop" : false,
	"buttons" : 0,
	"font" : "Arial 10",
	"children" :
	[
		{
			"kind" : "box",
			"name" : "wbs_disp",
			"bounds" : "0,0,parent.width, parent.height",
			"bg" : "gray10",
			"timer" : "sdr:wbs_timer",
			"timer-period" : 200,
			"draw" : "sdr:wbs_draw",
			"size" : "sdr:wbs_size"
		}
	]
} var, wbs_window_obj

\ ===============================================================================
\ Data declarations

\ Display run
false var, wbs_run
\ Display data
32768 b:new 0x0 b:fill var, wbs_data
[] var, wbs_disp
\ Mutual exclusion
"wbs-render-s4" 1 G:sem var, wbs_sem
\ Window metrics
1024 var, wbs_width
160 var, wbs_height
\ Margins
: WBS_LEFT 40 ;
: WBS_RIGHT 0 ;
: WBS_TOP 10 ;
: WBS_BOTTOM 30 ;
: WBS_V_LAB_X 10 ;
: WBS_H_LAB_Y 10 ;
: WBS_H_LAB_X 15 ;
\ dBm scale
-60 var, wbs_dbm_high
-140 var, wbs_dbm_low
\ Radio frequencies
var r1_freq
var r2_freq
var r3_freq

\ ===============================================================================
\ Window Events
\ Size
: wbs_size	\ g w h --
	wbs_sem locked@ sem-wait
 	wbs_height ! wbs_width !
 	wbs_sem locked@ sem-post
;

\ Render
: wbs_timer	\ g --
	g:invalidate
;

\ ===============================================================================
\ Builder

\ Convert dBm to y offset
: wbs_db_to_y															\ db -- y
	wbs_height @ 														\ db height
	WBS_TOP WBS_BOTTOM n:+ n:- 							\ db height - margins
	wbs_dbm_low @ n:abs wbs_dbm_high @ n:abs n:- 	\ db height - margins db-range
	n:/																			\ db pix-per-db
	swap n:abs															\ pix-per-db abs-db
	wbs_dbm_high @ n:abs n:-								\ pix-per-db rel-abs-db
	n:* 																		\ pix-per-db abs-y
	WBS_TOP n:+ n:int												\ y
;

\ Add one data point
: wbs_add_point		\ a x -- a
	swap						\ x a
	1 pick					\ x a x
	a:@							\ x a dbm
	wbs_db_to_y			\ x a y
	rot							\ a y x
	a:new						\ a y x new-a
	0 2 pick n:int	\ a y x new-a 0 x
	a:!							\ a y x new-a
	1 3 pick n:int	\ a y x new-a 1 y
	a:!							\ a y x new-a(x,y)
	wbs_disp @ 			\ a y x new-a(x,y) wbs_disp
	2 pick rot 			\ a y x wbs_disp x new-a(x,y)
	a:!							\ a y x wbs_disp
	3drop						\ a
;

\ Build data array	
: wbs_build	\ a --
	\ The array contains width dbM values across the 0-60 MHz freq spectrum
	\ We simply convert the array into a (x,y) coordinate for plotting.
	\ Clear display data array
	wbs_disp @ a:clear drop
	\ Build array
	' wbs_add_point 0 wbs_width @ WBS_LEFT n:1+ n:- loop
	drop
;

\ ===============================================================================
\ Renderer

\ Add one node to the graph
: do_wbs_node	\ g idx wbs-data-item
	0 a:@ swap 1 a:@ nip 	\ gui idx x y
	rot 0 n:= if					\ gui x y
		swap WBS_LEFT n:+ swap
		g:moveto
	else
		swap WBS_LEFT n:+ swap
		g:lineto
	then
;

\ Close the WBS path so it can be filled
: complete_wbs_path		\ wbs-data gui -- 
	\ Line from the current end point to the bottom right
	wbs_width @ 1 n:- wbs_height @ 20 n:- g:lineto			
	\ Line from bottom right to bottom left
	WBS_LEFT wbs_height @ 20 n:- g:lineto			
	\ Line to the first point													
	\ swap 				\ gui wbs-data				
	\ 0 a:@ 			\ gui wbs-data 0th-value
	\ nip 				\ gui 0th-value
	\ a:@ swap 	\ gui x 0th-value
	\ 1 a:@ nip		\ gui x y
	\ g:lineto																																										
;

\ Make the WBS path
: make_wbs_path \ g --
	wbs_disp @ a:len 0 n:= if ;; then 
	' do_wbs_node a:each drop
	wbs_disp @ swap complete_wbs_path
;

\ Drawing
\ Freq labels
: get_freq_labels	\ idx -- label
	["0","5", "10","15","20","25","30","35","40","45","50","55","60"]
;

: get_freq_label	\ idx -- label
	get_freq_labels
	swap a:@ nip
;

: get_freq_label_idx	\ -- idx
	get_freq_labels a:len n:1- nip
;

: add_freq_labels								\	g idx -- g
	dup get_freq_label						\ g idx label
	swap													\ g label idx
	wbs_width @										\ g label idx width
	WBS_LEFT WBS_H_LAB_X n:+ n:- 	\ g label idx width - margins
	get_freq_label_idx n:/ 				\ g label idx width-per-label
	n:*	WBS_LEFT n:+							\ g label label-x-pos
	wbs_height @ WBS_H_LAB_Y n:- 	\ g label x y
	rot														\ g x y label
	g:draw-text-at								\ g
;

\ Decibel labels
: get_db_labels	\ -- labels
	["-60","-80","-100","-120","-140"]
;

: get_db_label	\ idx -- label
	get_db_labels
	swap a:@ nip
;

: get_db_label_idx	\ -- idx
	get_db_labels a:len n:1- nip
;

: add_db_labels									\	g idx -- g
	dup get_db_label							\ g idx label
	swap													\ g label idx
	WBS_V_LAB_X swap							\ g label x idx
	wbs_height @ 									\ g label x idx height
	WBS_BOTTOM WBS_TOP n:+ n:- 		\ g label x idx height - margins
	get_db_label_idx n:/ 					\ g label x idx height-per-label
	n:* WBS_TOP n:+								\ g label x label-y-pos
	rot 													\ g x y label
	g:draw-text-at								\ g
;

\ Radio frequencies
: f_to_x	\ f -- x
	wbs_width @ WBS_LEFT WBS_RIGHT n:+ n:-	\ f y-span
	60000000.0 n:/													\ f pix-per-hz
	n:* WBS_LEFT n:+ n:int									\ x
;

: wbs_plot_radio_freq								\ g top x text -- g
	>r																\ g top x r:text
	rot over													\ top x g x
	3 pick														\ top x g x y
	g:moveto													\ top x g
	over wbs_height @ WBS_BOTTOM n:-	\ top x g x y
	g:lineto													\ top x g
	swap 2 roll r>										\ g x top text
	g:draw-text-at										\ g
;

: wbs_radio_freq										\ g -- g
	get_num_rx >r
	"red" g:scolor
	g:path
	WBS_TOP r1_freq @ f_to_x "R1" wbs_plot_radio_freq	\ g x text
	g:/path g:stroke
	r@ 1 n:> if
		"orange" g:scolor
		g:path
		WBS_TOP 10 n:+ r2_freq @ f_to_x "R2" wbs_plot_radio_freq	\ g x text
		g:/path g:stroke
	then
	r@ 2 n:> if
		"yellow" g:scolor
		g:path
		WBS_TOP 20 n:+ r3_freq @ f_to_x "R3" wbs_plot_radio_freq	\ g x text
		g:/path g:stroke
	then
	rdrop
;

\ Draw all
: wbs_draw	\ g --
	\ Critical section start
	wbs_sem locked@ sem-wait
	
	\ Common settings
	"gray11" g:fillall
	1 g:line-width
	
	\ Draw freq scale
	"red" g:scolor
	' add_freq_labels 0 get_freq_label_idx loop
	' add_db_labels 0 get_db_label_idx loop
	
	\ Draw the graph
	g:clearpath
	\ Line color
	"green:50" g:scolor
	"green:30" g:fcolor
	\ Do path
	
	make_wbs_path
	g:/path g:stroke-fill
	
	\ Draw radio frequencies
	wbs_radio_freq
	
	\ Critical section end
	wbs_sem locked@ sem-post
;

\ ===============================================================================
\ Subscriber events
: wbs_evt_r1_vfo	\ a --
	"freq" m:@ r1_freq !
	drop
;

: wbs_evt_r2_vfo
	"freq" m:@ r2_freq !
	drop
;

: wbs_evt_r3_vfo
	"freq" m:@ r3_freq !
	drop
;

\ ===============================================================================
\ WBS task

\ Build the display on a separate thread
\ Runs every 200ms
: wbs_task			\ --
	\ Name this thread
	"wbs_task" t:name!
	t:curtask . cr
	
	\ Subscribe to events
	UI_R1_FREQ ' wbs_evt_r1_vfo pubsub_subscribe
	UI_R2_FREQ ' wbs_evt_r2_vfo pubsub_subscribe
  UI_R3_FREQ ' wbs_evt_r3_vfo pubsub_subscribe
  SYS_R1_FREQ ' wbs_evt_r1_vfo pubsub_subscribe
	SYS_R2_FREQ ' wbs_evt_r2_vfo pubsub_subscribe
  SYS_R3_FREQ ' wbs_evt_r3_vfo pubsub_subscribe
  
	\ Do until terminated
	repeat
		\ Check for terminate
		\ Note - do not use break as this terminates on the next iteration
		\ which allows the lock to be taken and possibly not released.
		wbs_term @ if ;; then
		wbs_run @ if
			wbs_sem locked@ sem-wait
			wbs_width @ WBS_LEFT n:- wbs_data @ c_i_server_get_wbs_data wbs_build
			wbs_sem locked@ sem-post
		then
		0.2 sleep
	again
	"Wide bandscope task exiting..." log
;

\ ============================================================================		
\ Restore namespace	
ns: user	