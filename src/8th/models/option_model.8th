(*
	options_model.8th
 
  Radio options model for the SDRLibEConsole application
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

needs stack/3drop

\ ========================================
\ Testing only
false var, option_model_test
option_model_test @ #if
	\ Includes
	"../framework/param_st.8th" f:include
	"../framework/gen_server.8th" f:include
	"../framework/struct_manip.8th" f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
	"../framework/pub_sub.8th"  f:include
	"../testing/test_sink.8th" f:include
	"../common/persist.8th" f:include
	"../common/radio_defs.8th" f:include
	"model_common.8th" f:include
	\ needs debug/sed
	\ true SED-CHECK
	\ 4 json-pretty
	\ Test audio data (normally supplied by server)
	: c_i_server_enum_audio_inputs
		{
			"inputs" :
			[
				{
					"channels":2,
					"direction":0,
					"index":1,
					"api":"MME",
					"name":"Microphone [Realtek High Defini"
				},
	
				{
					"channels":8,
					"direction":0,
					"index":2,
					"api":"MME",
					"name":"Line 2 [Virtual Audio Cable]"
				}
			]
		}
	;
	
	: c_i_server_enum_audio_outputs
		{
				"outputs" :
				[
					{
						"channels":2,
						"direction":1,
						"index":1,
						"api":"MME",
						"name":"Speakers"
					},
		
					{
						"channels":8,
						"direction":1,
						"index":2,
						"api":"MME",
						"name":"Line 3 [Virtual Audio Cable]"
					}
				]
		}
	;
	
#then
\ ========================================

\ Define our SDR namespace
ns: sdr

(*
	GEN_SERVER application -
	Model for options -
		1. The model has a default which is used if there is no persisted model. If there is a persisted
		model this is restored and used as the current model.
		2. The model is saved at end of day and may be saved at other times as a precaution.
		3. This model contains all the data and settings for the options. It is used to both populate the
		UI and to set the current values. In some cases values are obtained at runtime [such as the current
		audio devices].
*)

\ ===============================================================================
\ PRIVATE
\ Convention: private words start __option_
\ 						message handlers start do_option_
\ ===============================================================================

\ Variables that holds the current audio device information
\ Of the form -
(*
	{
		"inputs" | "outputs":
		[
			{
				"channels":2,
				"direction":0,
				"index":1,
				"api":"MME",
				"name":"Microphone [Realtek High Defini"
			},

			{
				"channels":8,
				"direction":0,
				"index":2,
				"api":"MME",
				"name":"Line 2 [Virtual Audio Cable]"
			},
			...
		]
	}
*)

\ ----------------------------------
\ Default app model structure
\ Model data which is used as default when there is no saved model.
: __option_model_default	\	-- default-structure
	
	\ ToDo: Are the src and SOD flags necessary??	
	
	{
		"general" : {
		\	key								src			index/val 	SoD			option list			
			"smplrate" : 			[false, [0, 				true, 	["48000", "96000", "192000"]]],
			"numrx" : 				[false, [0, 				true, 	["1", "2", "3"]]],
			"blksz" : 				[false, [1, 				true, 	["512", "1024", "2048", "4096"]]]
		},
		"audio" : {
			"inputsrc" : 			[false, [0, 				true, 	["HPSDR", "Local"]]],
			"inputdev" : 			[false, [0, 				true, 	[]]],
			"outputsnk" :			[false, [0, 				true, 	["HPSDR", "Local"]]],
			"receiver" :			[false, [0, 				true, 	["1","2","3"]]],
			"outputdev" :			[false, [0, 				true, 	[]]],
			"channel" :				[false, [0, 				true, 	["Left","Right","Both"]]],
			\ Routes [[sink, rx, device, ch],[...],...]
			"routes" :		[]
		},
		"antenna" : {
		},
		"receiver" : {
			\	key						src			index/val 	SoD			option list			
			"avmode" : 		[false, [0, 				true, 	["Time Average Log", 
																								"Peak Detect",
																								"No Average",
																								"Time Average Linear",
																								"Time Average Log",
																								"Window Average Linear",
																								"Window Average Log",
																								"Low Noise Floor Linear",
																								"Low Noise Floor Log"]]],
			"avover" : 		[false, [0, 				true, 	["10", "20", "30", "40", "50", "60"]]],
			"wintype" : 	[false, [0, 				true, 	["Rectangular",
																								"Blackman-Harris",
																								"Hann",
																								"Flat-top",
																								"Hamming",
																								"Kaiser"]]],
			"fftsize" : 	[false, [0, 				true, 	["4096", "8192", "16384", "32768", "65536"]]]
		},
		"transmitter" : {
			"tunelevel" : [false, [20, 		true, 	[]]]
		}	
	}
;

\ ========================================
\ Model management

\ ----------------------------------
\ Get model
: __option_model@	SED: -- m
	\ in: 	none
	\ out:	model
	"option_model" t:@ ;

\ ----------------------------------
\ Save model
: __option_model!	SED: m -- 
	\ in: 	model
	\ out:	none
	"option_model" t:! ;

\ ----------------------------------
\ Return number of RX channels from the database
: __option_get_db_num_rx	SED: -- n
	\ in: 	none
	\ out:	0: n - num rx
	__option_model@ ["general", "numrx", ` dyn_idx ` , ` lst_idx ` ] ["general", "numrx", ` dyn_idx ` , ` val_or_idx ` ] idx_val@ >n ;

\ ----------------------------------
\ Copy db fields to local value holders
: __option_copy_to_holding_vars	SED: --
	\ in: 	none
	\ out:	none
	\ Only need num-rx at present as we must give the current number and not the new number as restart required
	__option_get_db_num_rx st_rad_num_rx!

\ ----------------------------------
\ Restore model else use the default
: __option_model_restore	SED: --
	\ in: 	none
	\ out:	none
	\ Restore the option model or use default if no saved model
	__option_model_default OPTION_MODEL_FILENAME restore_model_data __option_model!
	\ Copy any required current values into holding vars
	__option_copy_to_holding_vars ;

\ ----------------------------------
\ Save current model 
: __option_model_save	SED: --
	\ in: 	none
	\ out:	none
	\ Save the option model
	__option_model@ OPTION_MODEL_FILENAME save_model_data drop ;

\ ===============================================================================
\ Audio device management
\ Set audio section lists
\ Build the device list as api:index:name

: __option_build_device_name_array	\ a:device-names idx device-data	-- a:+device_name
	nip 
	"name" m:@ 
	swap "index" m:@  
	swap "api" m:@ nip
	"%s:%d:%s" s:strfmt a:push ;

(*
\ ----------------------------------
\ Populate input device list
: __option_set_input_device_list	\	 --
	\ Get device list from the C layer
	c_i_server_enum_audio_inputs dup "audio_device_inputs" t:! "inputs" m:@ nip
	\ Get array of device names
	a:new swap ' __option_build_device_name_array a:each drop
	\ Populate model
	>r __option_model@ ["audio","inputdev", ` dyn_idx ` ] lst_idx r> val! drop ;

\ ----------------------------------
\ Populate output device list
: __option_set_output_device_list	\	 --
	\ Get device list from the C layer
	c_i_server_enum_audio_outputs dup "audio_device_outputs" t:! "outputs" m:@ nip
	\ Get array of device names
	a:new swap ' __option_build_device_name_array a:each drop
	\ Populate model
	>r __option_model@ ["audio","outputdev", ` dyn_idx ` ] lst_idx r> val! drop ;
*)

\ ----------------------------------
\ Send restored/default UI data to all subscribers
: __option_ui_evnts	SED: --
	\ in: 	none
	\ out:	none
	__option_model@ >r
	\ The model has been restored from disc at this point
	\ First get the current audio devices from the C layer
	\ as these are dynamic so have to be refreshed.
	\ __option_set_input_device_list
	\ __option_set_output_device_list
	
	UI_SMPL_RATE r@ ["general", "smplrate", ` dyn_idx `] val@ fr:pubsub_publish
	UI_NUM_RX r@ ["general", "numrx", ` dyn_idx `] val@ fr:pubsub_publish
	UI_BLK_SZ r@ ["general", "blksz", ` dyn_idx `] val@ fr:pubsub_publish
	UI_INPUT_SRC r@ ["audio", "inputsrc", ` dyn_idx `] val@ fr:pubsub_publish
	UI_INPUT_DEV r@ ["audio", "inputdev", ` dyn_idx `] val@ fr:pubsub_publish
	UI_OUTPUT_SINK r@ ["audio", "outputsnk", ` dyn_idx `] val@ fr:pubsub_publish
	UI_RECEIVER r@ ["audio", "receiver", ` dyn_idx `] val@ fr:pubsub_publish
	UI_OUTPUT_DEV r@ ["audio", "outputdev", ` dyn_idx `] val@ fr:pubsub_publish
	UI_CHANNEL r@ ["audio", "channel", ` dyn_idx `] val@ fr:pubsub_publish
	UI_AVMODE r@ ["receiver", "avmode", ` dyn_idx `] val@ fr:pubsub_publish
	UI_AVOVER r@ ["receiver", "avover", ` dyn_idx `] val@ fr:pubsub_publish
	UI_WINTYPE r@ ["receiver", "wintype", ` dyn_idx `] val@ fr:pubsub_publish
	UI_FFT_SIZE r@ ["receiver", "fftsize", ` dyn_idx `] val@ fr:pubsub_publish
	UI_TUNE_LEVEL r> ["transmitter", "tunelevel", ` dyn_idx `] val@ fr:pubsub_publish
	
	"Options sent UI events " log 
;

\ ----------------------------------
\ Send restored/default SYS data to all subscribers
: __option_sys_evnts	SED: --
	\ in: 	none
	\ out:	none
	__option_model@ >r
	
	SYS_SMPL_RATE r@ ["general", "smplrate", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_NUM_RX r@ ["general", "numrx", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_BLK_SZ r@ ["general", "blksz", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_INPUT_SRC r@ ["audio", "inputsrc", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_INPUT_DEV r@ ["audio", "inputdev", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_OUTPUT_SINK r@ ["audio", "outputsnk", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_CHANNEL r@ ["audio", "channel", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_AUDIO_ROUTE r@ ["audio", "routes"] val@ fr:pubsub_publish
	SYS_AVMODE r@ ["receiver", "avmode", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_AVOVER r@ ["receiver", "avover", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_WINTYPE r@ ["receiver", "wintype", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_FFT_SIZE r@ ["receiver", "fftsize", ` dyn_idx `] val@ fr:pubsub_publish
	SYS_TUNE_LEVEL r> ["transmitter", "tunelevel", ` dyn_idx `] val@ fr:pubsub_publish

	"Options sent SYS events" log 
;

\ ========================================
\ Message Handlers
\ ========================================

\ Initialise the option model at task level
: do_option_init	SED: a --
	\ in: 	message
	\ out:	none
	drop __option_model_restore ;

\ ----------------------------------
\ Send events
: do_option_ui_evnts	SED: m --
	\ in: 	message
	\ out:	none
	drop __option_ui_evnts
;

: do_option_sys_evnts	SED: m --
	\ in: 	message
	\ out:	none
	drop __option_sys_evnts
;

\ ----------------------------------
\ Close the app model at task level
: do_option_close	SED: a --
	\ in: 	message
	\ out:	none
	drop __option_model_save ;

\ ============================================
\ Get/Set general section value holders

\ ----------------------------------
\ Number of receivers
: do_option_set_num_rx	SED: a --
	a:open
	\ in: 	0: n - num rx
	\ out: 	none
	>r __option_model@ ["general","numrx", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Sample rate
: do_option_set_sample_rate	SED: a --
	a:open
	\ in: 	0: n - sample rate
	\ out: 	none
	>r __option_model@ ["general","smplrate", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Block size
: do_option_set_blk_sz	SED: a --
	a:open
	\ in: 	0: n - block size
	\ out: 	none
	>r __option_model@ ["general","blksz", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ============================================
\ Get/Set audio section value holders
\ Set the input dource to HPSDR/Local
: do_option_set_input_source	SED: a --
	a:open
	\ in: 	0: s - input source name
	\ out: 	none
	>r __option_model@ ["audio","inputsrc", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Set audio input device if local
: do_option_set_input_device	SED: a --
	a:open
	\ in: 	0: s - input device name
	\ out: 	none
	>r __option_model@ ["audio","inputdev", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Set output sink index
: do_option_set_output_sink	SED: a --
	a:open
	\ in: 	0: s - output sink name
	\ out: 	none
	>r __option_model@ ["audio","outputsnk", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Get the output sink index
: do_option_get_output_sink	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: n - output sink index
	__option_model@ ["audio","outputsnk", ` dyn_idx ` , ` lst_idx ` ] ["audio","outputsnk", ` dyn_idx ` , ` val_or_idx ` ] idx_val@
	fr:response! ;

\ ----------------------------------
\ Set receiver index
: do_option_set_receiver	SED: a --
	a:open
	\ in: 	0: s - receiver index number as s
	\ out: 	none
	>r __option_model@ ["audio","receiver", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
: do_option_get_receiver	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: n - receiver index
	__option_model@ ["audio","receiver", ` dyn_idx ` , ` lst_idx ` ] ["audio","receiver", ` dyn_idx ` , ` val_or_idx ` ] idx_val@
	fr:response! ;

\ ----------------------------------
\ Set output device name
: do_option_set_output_device	SED: a --
	a:open
	\ in: 	0: s - output device name
	\ out: 	none
	>r __option_model@ ["audio","outputdev", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Get output device name
: do_option_get_output_device	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: s - output device name
	__option_model@ ["audio","outputdev", ` dyn_idx ` , ` lst_idx ` ] ["audio","outputdev", ` dyn_idx ` , ` val_or_idx ` ] idx_val@
	fr:response! ;

\ ----------------------------------
\ Set channel type
: do_option_set_channel	SED: s --
	a:open
	\ in: 	0: s - set channel L/R/Both
	\ out: 	none
	>r __option_model@ ["audio","channel", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Get channel name
: do_option_get_channel	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: s - channel name
	__option_model@ ["audio","channel", ` dyn_idx ` , ` lst_idx ` ] ["audio","channel", ` dyn_idx ` , ` val_or_idx ` ] idx_val@ ;

\ ========================================
\ Audio Route Management

\ Get/set audio routes
\ Remove the given audio route
: do_option_remove_route	SED: a --
	a:open
	\ in: 	0: n - route index
	\ out: 	none
	__option_model@ ["audio","routes" ] val@ swap a:- ;

\ ----------------------------------
\ Get all current routes
: __option_get_routes	SED:  -- a
	\ in: 	none
	\ out: 	0: a - route array
	__option_model@ ["audio","routes" ] val@ ;

\ ----------------------------------
\ Get all current routes
: do_option_get_routes	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: a - route array
	__option_get_routes
	fr:response! ;

\ ----------------------------------
\ Get route count
: do_option_get_route_count	SED: a --
	a:open
	\ in: 	0: q - sender (task name)
	\ out: 	q: a - route array
	__option_get_routes a:len
	fr:response! ;

\ ----------------------------------
\ Push route to the model
: do_option_push_route	SED: a --
	a:open
	\ in: 	0: a - new route
	\ out: 	none
	\ pre:	route must have been validated
	__option_model@ ["audio","routes" ] val@ swap a:push
	\ Publish all routes as we don't know what changed, we may have deleted some etc
	SYS_AUDIO_ROUTE __option_model@ ["audio","routes" ] val@ fr:pubsub_publish ;

\ ============================================
\ Get/Set receiver section value holders
\ Set the average mode type
: do_option_set_average_mode	SED: a --
	a:open
	\ in: 	0: n - av mode index
	\ out: 	none
	>r __option_model@ ["receiver","avmode", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Set the number of cycles to average over
: do_option_set_over	SED: a --
	a:open
	\ in: 	0: n - average over n cycles
	\ out: 	none
	>r __option_model@ ["receiver","avover", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Set the window type for averaging
: do_option_set_window_type	SED: a --
	a:open
	\ in: 	0: s - window type
	\ out: 	none
	>r __option_model@ ["receiver","wintype", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ----------------------------------
\ Set display FFT size
: do_option_set_fft_size	SED: a --
	a:open
	\ in: 	0: n - fft size
	\ out: 	none
	>r __option_model@ ["receiver","fftsize", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ============================================
\ Get/Set transmitter section value holders
\ Set the TX tune level
: do_option_set_tune_level	SED: a --
	a:open
	\ in: 	0: n - tune level 0-100
	\ out: 	none
	>r __option_model@ ["transmitter","tunelevel", ` dyn_idx ` ] val_or_idx r> val! drop ;

\ ===============================================================================
\ PUBLIC
\ Public procedural interface, call from any thread
\ ===============================================================================

\ ========================================
\ Initialise /destroy
\ ----------------------------------
\ Module initialisation
: option_model_init	SED: --
	\ in: 	none
	\ out:	none
	\ Create the app model gen-server
	"OptionsModel_TASK" t:curtask 2 ' fr:gen_server t:task-n -1 sleep drop
	\ Ask the model to initialise itself
	"OptionsModel_TASK" ' do_option_init a:new fr:msg!
	"Options model initialised sent" log ;

\ ----------------------------------
\ UI events
: option_model_ui_evnts	SED: --
	"OptionsModel_TASK" ' do_option_ui_evnts a:new fr:msg! ;

\ ----------------------------------
\ SYS events
: option_model_sys_evnts	SED: --
	"OptionsModel_TASK" ' do_option_sys_evnts a:new fr:msg! ;
	
\ ----------------------------------
\ Module close
: option_model_term	SED: --
	\ in: 	none
	\ out:	none
	\ Tidy close the model
	"OptionsModel_TASK" ' do_option_close a:new fr:msg!
	0.5 sleep
	\ Ask the model to exit
	"OptionsModel_TASK" ' fr:gs_do_term a:new fr:msg! ;

\ ========================================
\ Restore namespace	
ns: user	

\ ===============================================================================
\ Testing
\ ===============================================================================
option_model_test @ #if

	\ Common initialisation
	: setup
		"Doing setup" log
		\ Param stack alloc
		param_st_alloc
		\ Pub/sub init
		' sdr:do_registrations fr:pubsub_init
		\ Set up test sink subscriptions
		sdr:test_registrations
		"Setup complete" log
	;
	
	\ Run the procedural tests
	: run_proc
	;
	
	\ Run one test iteration
	: runtest
		cr cr "Run test: " swap >s s:+ log
		\ Initialise and do SOD etc
		"Initialising" log
		sdr:option_model_init
		sdr:option_model_ui_evnts
		sdr:option_model_sys_evnts
		"Done initialise" log
		\ Run proc tests
		"Running proc tests" log
		\ run_proc
		2.0 sleep
		"Done proc tests" log
		\ Close options model to clean up for next iteration
		"Closing model" log
		sdr:option_model_term 
		"OptionsModel_TASK" fr:gs_wait_single_task 
		"Done closing model" log
		2 sleep
	;

	\ Run tests on a separate thread
	: run_tests
		t:getq false q:throwing drop
		"TEST_TASK" t:name!
		t:curtask "TEST_TASK" fr:gs_reg!
		setup	
		2 sleep
		' runtest 1 10 loop
		\ Terminate pub/sub
		cr "Closing test..." log
		fr:pubsub_term		
		\ Wait for P/S to terminate
		\ OptionsModel_TASK already terminated
		"P/S_TASK" fr:gs_wait_single_task 
		"TEST_TASK exiting..." log
	;

	\ Test sequence
	"MAIN_TASK" t:name!
	' run_tests t:task
	\ Wait for main task to terminate
	t:wait
	2 sleep
	bye
	
#then