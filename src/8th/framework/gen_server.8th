(* 
	gen_server.8th
 
  A general purpose server to be used for all tasks that require the
  messaging infrastructure.
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ========================================
\ Testing only
false var, gen_server_test

\ ----------------------------------
gen_server_test @ #if
	\ Includes
	"param_st.8th"  f:include
	\ needs debug/sed
	\ true SED-CHECK
#then
\ ========================================

\ Set namespace
ns: fr

(*
	This module is loosly based on the erlang gen-server in that it emulates a 
	process oriented message passing concurrency model.
	
	This is part of the generic framework in the namespace fr:.
*)

\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ ===============================================================================

\ ===============================================================================
\ Task reference and termination management

\ Holder for task references
\ Global var, requires lock semantics
{} var, __task_dict

\ ----------------------------------
\ Locked var
: __gs_lock@
	__task_dict lock @ ;

\ ----------------------------------
\ Unlocked var	
: __gs_unlock
	__task_dict unlock drop ;

\ ----------------------------------	
\ Store task referance
: __gs_reg!	SED: t s --
	\ in: 	t - task object
	\				s - task name
	\ out:	none
	__gs_lock@
	swap rot  m:! drop 
	__gs_unlock ;

\ ----------------------------------	
\ Get task referance
: __gs_reg@	SED: s -- t
	\ in: 	0: s - task name
	\ out:	0: t - task ref
	__gs_lock@
	swap m:@ nip 
	__gs_unlock ;

\ ===============================================================================
\ PUBLIC
\ Generic task for implementing messaging passing concurrency
\ Convention: any private words used as helpers start __
\ ===============================================================================

\ ----------------------------------
\ Register an external task
: gs_reg!	SED: t s --
	__gs_reg! ;
	
\ ----------------------------------
\ Wait for task to terminate
: __gs_wait_task SED: s t --
	\ in:		t - task ref 	(item from dict) 	
	\				s - task name (key from dict)
	\ out:	none
	"Waiting for task: " rot s:+ log
	t:wait ;

\ ----------------------------------
\ Wait for all tasks to terminate
: gs_wait_all	SED: --
	__gs_lock@
	' __gs_wait_task m:each
	1 sleep
	m:clear
	__gs_unlock drop ;

\ ----------------------------------
\ Wait for task to terminate
: gs_wait_single_task	SED: s --
	dup >r "Waiting for task: " swap s:+ log
	__gs_lock@
	r@ m:@ t:wait
	r> m:-
	__gs_unlock drop ;
	
\ ----------------------------------
\ Terminate task
\ This is called from the task to terminate itself
\ It sets the run task var to false which is then tested within gen_server
: gs_do_term  SED: a --
	\ in: 	0: []
	\ out:	none
	drop false t:name@ "_run" s:+ t:!
;

\ ----------------------------------
\ Process 1 item from task Q	
: __gs_proc_q	SED: --
	t:pop null? if
		"Warning, p/s q returned null!" log drop
	else
		\ Message to process, just send data part
		"data" m:@ swap "cb" m:@ nip w:exec
	then ;
	
\ ===============================================================================
\ Task entry point for all generic servers
: gen_server	 SED: s t --
	\ in: 	0 t: calling task
	\				1 s: this task name
	\ out:	none
	\ Assign name and store in registry
	>r dup t:name! t:curtask swap __gs_reg!
	
	\ Set us in the run state using a task variable
	true t:name@ "_run" s:+ t:!
	\ Init the param stack for this task
	param_st_alloc
	
	\ Set q to return null on empty
	\ Note, should not happen
	t:getq false q:throwing drop
	\ Wake up main thread which is waiting for us to finish initialisation
	r> t:notify
	
	\ Loop while run enabled
	repeat
		\ Wait for a wake up notify
		-1 sleep
		' __gs_proc_q t:qlen 
		\ Check q length
		dup 1 n:> if "Q: " . t:qlen . cr cr then 
		times
		\ Check for exit
		t:name@ "_run" s:+ t:@
		\ Check for stack problem, only the T value should be on stack at this point.
		depth 1 n:> if
			"Task " t:name@ s:+ " warning - stack growing [" s:+ depth >s s:+ "]!" s:+ log
		then
	while!
	t:name@ " - exiting..." s:+ log ;

\ ===============================================================================
\ Message management
\ Words are kept minimal, no gs prefix as they are used frequently

\ ----------------------------------
\ Message send to a given word on a given task name queue
: msg!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ Push params and copy task name to r
	>p >p >r
	\ Word to invoke under the "cb" key and data under the "data" key
	\ The data is cloned before the send as it must be detached from the current task pool
	m:new "cb" p> m:! "data" p> m:!
	\ Clone the whole message structure and push to the task q
	clone nip
	\ Get task for name and lock task-dict
	r> __gs_lock@ swap m:@ nip 
	\ Push message to task q
	dup >r swap t:push r> t:notify 
	\ Release lock
	__gs_unlock 
	0.01 sleep ;

\ ----------------------------------
\ Message response to sender

\ Add sender to message
: +sender	SED:	a -- a
	\ in: 	0: a - message array
	\ out: 	0: a - [sender name for response]
	t:name@ a:push ;
	
\ ----------------------------------
\ Get task response for synchronous sends
: response@	SED: -- *
	\ in: 	none
	\ out: 	0: * - opaque response data
	t:pop null? if
		\ Nothing yet, so wait a while
		drop -1 sleep t:pop null? if 
			drop "Timeout waiting for task response!" log 
			"???"
		then
	then ;

\ ----------------------------------
\ Push response data to sender
: response!	SED: s * --
	\ in: 	0: * - response data
	\				1: s - sender (task name)
	\ out: 	none
	swap fr:__gs_reg@ swap 
	\ Clone opaque response data
	clone nip
	\ Push to given q and notify caller
	2dup t:push drop t:notify
;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ Testing
\ ===============================================================================
gen_server_test @ #if

	: iterations 10 ;
	
	: make_task	\ n --
		"t" swap >s s:+ t:curtask 2 ' fr:gen_server t:task-n
		-1 sleep drop
	;
	
	: make_tasks	\ --
		' make_task 1 iterations loop
	;

	: term_task	\ n --
		"t" swap >s s:+ ' fr:gs_do_term a:new fr:msg!
	;

	: term_all
		' term_task 1 iterations loop
	;

	: runtest
		"Run: " swap >s s:+ log
		make_tasks
		1 sleep
		term_all
		fr:gs_wait_all
		fr:__task_dict @ m:clear
		0.2 sleep
		\ depth . " " . dstack st:len nip . " " . pdepth . cr
	;
	
	param_st_alloc
	' runtest 1 5 loop
		
	bye
#then	