(* 
	param_st.8th
 
  Parameter storage
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ========================================
\ Testing only
false var, param_st_test

param_st_test @ #if
	\ 18.08.2 SED: works single task only
	\ needs debug/sed
	\ true SED-CHECK
#then
\ ========================================

(*
	Provides an extra stack per task to offload parameters.
	Theis leaves the data stack and the r stack for local manipulation.
	Be very careful to leave the P stack exactly as found after each word in a
	hierarchy of calls as pervious words may be using the parameters. In any
	event do not clear the stack except at the end of a call sequence.
	
	This is part of the generic framework in the namespace user:.
*)

\ ========================================

\ Max params per stack (depth)
: PS_MAX_PARAMS 20 ;
	
\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ This is left in the user namepace rather than fr: for ease of use
\ ===============================================================================

\ Return the stack associated with the calling task
: __pss@	 SED: -- *
	\ in: 	none
	\ out:	s0 - stack | null 
	"p_st" t:@ ;

\ ----------------------------------
\ Store the given stack for the current task
: __pss!	 SED: st --
	\ in: 	stack
	\ out:	none
	"p_st" t:! ;

\ ----------------------------------
\ Pop TOS from the task param stack
: __ps>	 SED: -- *
	\ in: 	none
	\ out:	item of any type
	__pss@ null? if
		"__ps> attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then
	st:pop nip ;

\ ----------------------------------
\ Copy TOS from the task param stack 
: __ps@	 SED: -- *
	\ in: 	none
	\ out:	item of any type
	__pss@ null? if
		"pa@ attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then
	0 st:pick nip ;

\ ----------------------------------
\ Pick item n from the task param stack 	
: __pps@	 SED: n -- *
	\ in: 	item index
	\ out:	item of any type
	__pss@ null? if
		"p__ps@ attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then
	swap st:pick nip ;

\ ----------------------------------
\ Push the given item to the task param stack
: __ps!	 SED: * --
	\ in: 	item of any type
	\ out:	none
	__pss@ null? if
		"ps! attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then
	swap st:push drop ;

\ ----------------------------------
\ Check if initialised for current task
\ Throw exception if not initialised
: __param_st_check  SED: --
	\ in: 	none
	\ out:	none
	__pss@ null? if
		"param_st_check attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then drop ;

\ ===============================================================================
\ PUBLIC	
\ ===============================================================================

\ Allocate a parameter stack for the given task
\ Must be called by each task first AFTER it has set a unique task name
: param_st_alloc	 SED: --
	\ in: 	none
	\ out:	none
	__pss@ null? if
		\ No previous allocation for this task
		\ Create a new entry
		drop PS_MAX_PARAMS st:new __pss!
	else
		drop "Param stack already initialised for task [" t:name@ s:+ "]. Ignoring!" s:+ log
	then ;

\ Ensure the stack is freed
: param_st_free	SED: --
	\ in: 	none
	\ out:	none
	__pss@ null? if
			"param_st_free attempt before the parameter stack has been initialised for task [" t:name@ s:+ "]!" s:+ nip throw
	then free ;

\ ========================================
\ Parameter stack operations

\ ----------------------------------
\ Store TOS to task param stack
: >p	 SED: * --
	\ in: 	any type
	\ out:	none
	__param_st_check
	__ps! ;

\ ----------------------------------
\ Retrieve TOS from task param stack
: p>  SED: -- *
	\ in: 	none
	\ out:	any type
	__param_st_check
	__ps> ;

\ ----------------------------------
\ Copy TOS from task param stack
: p@	 SED: -- *
	\ in: 	none
	\ out:	any type
	__param_st_check
	__ps@ ;

\ ----------------------------------
\ Copy item n from task param stack
: pp@ SED: n -- *
	\ in: 	none
	\ out:	any type
	__param_st_check
	__pps@ ;

\ ----------------------------------
\ Drop n items from task param stack
: pndrop SED: n -- 
	\ in: 	none
	\ out:	any type
	__param_st_check
	__pss@ swap st:ndrop drop ;
	
\ ----------------------------------	
\ Clear task param stack
: pclear SED:  -- 
	__param_st_check
	__pss@ st:clear drop ;

\ ----------------------------------
\ Stack depth
: pdepth SED:  -- n
	__param_st_check
	__pss@ st:len nip ;
	
\ ----------------------------------	
\ Print the task stack


\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================
param_st_test @ #if
	\ Usage test
	: tn	\ name --
		t:name!
		param_st_alloc
		1 2 3 4 5 >p >p >p >p >p
		p> p> p> p> p>
		1 2 3 4 5 >p >p >p >p >p
		p@ p@ p@ p@ p@
		1 2 3 4 5 >p >p >p >p >p
		0 pp@ 1 pp@ 2 pp@ 3 pp@ 4 pp@ 5 pp@
		p> p> p> p> p> p> p> p> p> p>
		t:name@ " done" s:+ log
	;

	[] var, ps_tasks

	: run_task	\ n -- 
		"Task-" swap >s s:+ 1 ' tn t:task-n ps_tasks @ swap a:push drop
	;

	: usage_test	\ --
		' run_task 1 500 loop
		0.1 sleep
	;

	cr cr "Running usage test..." . cr cr
	usage_test
	1 sleep
	"Done usage test" . cr
	bye
#then