(* 
	task_man.8th
 
  Task management
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ========================================
\ Testing only
false var, task_man_test

\ ----------------------------------
task_man_test @ #if
	\ Includes
	"param_st.8th"  f:include
	\ needs debug/sed
	\ true SED-CHECK
#then
\ ========================================

\ Set namespace
ns: fr

\ ===============================================================================
\ Task reference and termination management

\ Holder for task references
{} var, __task_dict

\ ----------------------------------
\ Locked var
: locked_task_dict@
	__task_dict lock @ ;

\ ----------------------------------
\ Unlocked var	
: unlock_task_dict
	__task_dict unlock drop ;

\ ----------------------------------	
\ Store task referance
: task_reg!	SED: t s --
	\ in: 	t - task object
	\				s - task name
	\ out:	none
	locked_task_dict@
	swap rot  m:! drop 
	unlock_task_dict ;

\ ----------------------------------	
\ Get task referance
: task_reg@	SED: s -- t
	\ in: 	0: s - task name
	\ out:	0: t - task ref
	locked_task_dict@
	swap m:@ nip 
	unlock_task_dict ;
	
\ ----------------------------------
\ Wait for task to terminate
: wait_task SED: s t --
	\ in:		t - task ref 	(item from dict) 	
	\				s - task name (key from dict)
	\ out:	none
	"Waiting for task: " rot s:+ log
	t:wait ;

\ ----------------------------------
\ Wait for all tasks to terminate
: wait_all	SED: --
	locked_task_dict@
	' wait_task m:each
	1 sleep
	m:clear
	unlock_task_dict drop ;

\ ----------------------------------
\ Wait for task to terminate
: wait_single_task	SED: s --
	dup >r "Waiting for task: " swap s:+ log
	locked_task_dict@
	r@ m:@ t:wait
	r> m:-
	unlock_task_dict drop ;
	
\ ===============================================================================
\ Generic task for implementing messaging passing concurrency 

\ ----------------------------------
\ Terminate task
: do_term  SED: m --
	\ in: 	{ "type" : "term" }
	\ out:	none
	drop false t:name@ "_run" s:+ t:!
;

\ ----------------------------------
\ Process 1 item from task Q	
: proc_q	SED: --
	t:pop null? if
		"Warning, p/s q returned null!" log drop
	else
		\ Message to process, just send data part
		"data" m:@ swap "cb" m:@ nip w:exec
	then ;
	
\ ----------------------------------
\ Task entry point for generic servers
: gen_server	 SED: s t --
	\ in: 	0 t: calling task
	\				1 s: this task name
	\ out:	none
	\ Assign name and store in registry
	>r dup t:name! t:curtask swap task_reg!
	
	\ Set us in the run state using a task variable
	true t:name@ "_run" s:+ t:!
	\ Init the param stack for this task
	param_st_alloc
	
	\ Set q to return null on empty
	\ Note, should not happen
	t:getq false q:throwing drop
	\ Wake up main thread which is waiting for us to finish initialisation
	r> t:notify
	
	\ Loop while run enabled
	repeat
		\ Wait for a wake up notify
		-1 sleep
		' proc_q t:qlen 
		\ Check q length
		dup 1 n:> if "Q: " . t:qlen . cr cr then 
		times
		\ Check for exit
		t:name@ "_run" s:+ t:@
		\ Check for stack problem, only the T value should be on stack at this point.
		depth 1 n:> if
			"Task " t:name@ s:+ " warning - stack growing [" s:+ depth >s s:+ "]!" s:+ log
		then
	while!
	t:name@ " - exiting..." s:+ log ;

\ ===============================================================================
\ Message send to a given task
\ NOTE: leave p stack as we found it
: msg!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ Push params and copy task name to r
	>p >p >r
	\ Word to invoke under the "cb" key and data under the "data" key
	\ The data is cloned before the send as it must be detached from the current task pool
	m:new "cb" p> m:! "data" p> m:!
	\ Clone the whole message structure and push to the task q
	clone nip
	\ Get task for name and lock task-dict
	r> locked_task_dict@ swap m:@ nip 
	\ Push message to task q
	dup >r swap t:push r> t:notify 
	\ Release lock
	unlock_task_dict ;
	
\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ Testing
\ ===============================================================================
task_man_test @ #if

	: iterations 100 ;
	
	: make_task	\ n --
		"t" swap >s s:+ 1 ' fr:gen_server t:task-n
		-1 sleep drop
	;
	
	: make_tasks	\ --
		' make_task 1 iterations loop
	;

	: term_task	\ n --
		"t" swap >s s:+ ' fr:do_term a:new fr:msg!
		\ Memory creeps up between terminating and creating a new batch of tasks
		\ This is about the minimal sleep required. However it still increases.
		0.2 sleep
	;

	: term_all
		' term_task 1 iterations loop
	;

	: runtest
		"Run: " swap >s s:+ log
		make_tasks
		term_all
		\ fr:__task_dict @ . cr
		fr:wait_all
		fr:__task_dict @ m:clear
		0.2 sleep
		\ depth . " " . dstack st:len nip . " " . pdepth . cr
	;
	
	param_st_alloc
	' runtest 1 500 loop
		
	bye
#then	