(* 
	task_man.8th
 
  Task management
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ========================================
\ Testing only
false var, task_man_test

\ ----------------------------------
task_man_test @ #if
	\ Includes
	"param_st.8th"  f:include
	\ needs debug/sed
	\ true SED-CHECK
#then
\ ========================================

\ Set namespace
ns: fr

\ ===============================================================================
\ Task reference and termination management

\ Holder for task references
{} var, __task_dict

\ ----------------------------------
\ Locked var
: locked_task_dict@
	__task_dict lock @ ;

\ ----------------------------------
\ Unlocked var	
: unlock_task_dict
	__task_dict unlock drop ;

\ ----------------------------------	
\ Store task referance
: task_reg!	SED: t s --
	\ in: 	t - task object
	\				s - task name
	\ out:	none
	locked_task_dict@
	swap rot  m:! drop 
	unlock_task_dict ;

\ ----------------------------------	
\ Lock and get task reference by name
: task_reg_lock@	SED: s -- t
	\ in: 	s - task name
	\ out:	t - task reference
	locked_task_dict@
	swap m:@ nip
	unlock_task_dict ;
	
\ ----------------------------------
\ Wait for task to terminate
: wait_task SED: s t --
	\ in:		t - task ref 	(item from dict) 	
	\				s - task name (key from dict)
	\ out:	none
	"Waiting for task: " rot s:+ log
	t:wait ;

\ ----------------------------------
\ Wait for all tasks to terminate
: wait_all	SED: --
	locked_task_dict@
	' wait_task m:each 
	unlock_task_dict drop ;

\ ===============================================================================
\ Generic task for implementing messaging passing concurrency 

\ ----------------------------------
\ Terminate task
: do_term  SED: m --
	\ in: 	{ "type" : "term" }
	\ out:	none
	drop false t:name@ "_run" s:+ t:!
;

\ ----------------------------------
\ Process 1 item from task Q	
: proc_q	SED: --
	t:pop null? if
		"Warning, p/s q returned null!" log drop
	else
		\ Message to process, just send data part
		\ "cb" m:@ w:exec
		"data" m:@ swap "cb" m:@ nip w:exec
	then ;
	
\ ----------------------------------
\ Task entry point for generic servers
: gen_server	 SED: s --
	\ in: 	given name
	\ out:	none
	\ Assign name and store in registry
	dup t:name! t:curtask swap task_reg!
	
	\ Set us in the run state using a task variable
	true t:name@ "_run" s:+ t:!
	\ Init the param stack for this task
	param_st_alloc
	
	\ Set q to return null on empty
	\ Note, should not happen
	t:getq false q:throwing drop
	\ Wake up main thread which is waiting for us to finish initialisation
	t:main t:notify
	
	\ Loop while run enabled
	repeat
		\ Wait for a wake up notify
		-1 sleep
		' proc_q t:qlen times
		\ Check for exit
		t:name@ "_run" s:+ t:@
	while!
	t:name@ " - exiting..." s:+ log ;

\ ===============================================================================
\ Message send to a given task
: msg!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ Push params and copy task name to r
	const >p >p >r
	\ Word to invoke under the "cb" key and data under the "data" key
	\ The data is cloned before the send as it must be detached from the current task pool
	m:new "cb" p> m:! "data" p> m:! const
	r> task_reg_lock@ dup >r swap t:push r> t:notify ;
	
\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ Testing
\ ===============================================================================
task_man_test @ #if

	: iterations 100 ;
	
	: make_task	\ n --
		"t" swap >s s:+ 1 ' fr:gen_server t:task-n
		-1 sleep drop
	;
	
	: make_tasks	\ --
		' make_task 1 iterations loop
	;

	: term_task	\ n --
		"t" swap >s s:+ ' fr:do_term a:new fr:msg!
		\ Memory creeps up between terminating and creating a new batch of tasks
		\ This is about the minimal sleep required. However it still increases.
		0.2 sleep
	;

	: term_all
		' term_task 1 iterations loop
	;

	: runtest
		"Run: " swap >s s:+ log
		make_tasks
		term_all
		\ fr:__task_dict @ . cr
		fr:wait_all
		fr:__task_dict @ m:clear
		0.2 sleep
		\ depth . " " . dstack st:len nip . " " . pdepth . cr
	;
	
	param_st_alloc
	' runtest 1 500 loop
		
	bye
#then	