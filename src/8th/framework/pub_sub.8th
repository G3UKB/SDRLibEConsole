(*
	pub_sub.8th
 
  Publish/Subscribe system
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ Up the q a little
1000 t:def-queue

\ ========================================
\ Testing only
false var, pub_sub_test

pub_sub_test @ #if
	\ needs debug/sed
	\ true SED-CHECK
	\ Includes
	"param_st.8th"  f:include
	"gen_server.8th"  f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
#then
\ ========================================

\ Set namespace
ns: fr

(*
	GEN_SERVER application -
	This is a publish/subscribe system.
	1. A number of events are registered. Events are strings. 
	2. Once registered, events may be subscribed to by any number of recipients.
	3. Once registered an event may be published with an opaque data structure and
	will be dispatched to all subscribers [if any].
	4. Dispatch is on the P/S_THREAD for SYS events and on the main thread for UI events.
	This is convention but the registration includes a flag which is the actual indicator.
	
	This is part of the generic framework in the namespace fr:.
*)

\ ===============================================================================
\ PRIVATE
\ Convention: private words start __ps
\ 						message handlers start do_ps_
\ ===============================================================================

\ ========================================
\ General helper words
\ ----------------------------------
\ Return the pub/sub store	
: __ps_store@	 SED: -- m
	\ in: 	none
	\ out:	pub/sub store
	"ps_s" t:@ ;

\ ----------------------------------	
\ Retrieve the event name
: __ps_evnt_name@  SED: a -- s
	\ in: 	[evnt-name, f]
	\ out:	evnt-name
	0 a:@ nip ;
	
\ ========================================
\ Registration helper words
\
\ Retrieve the event flag
: __ps_evnt_flg@  SED: a -- T
	\ in: 	[evnt-name, f]
	\ out:	flag	
	1 a:@ nip ;	

\ ----------------------------------
\ Does the event name already exist
: __ps_exists?	 SED: a -- F
	\ in: 	[evnt-name, f]
	\ out:	flag
	__ps_evnt_name@ __ps_store@ swap m:exists? nip ;

\ ----------------------------------
\ Return default event data
: __ps_make_evnt_data	 SED: a -- a
	\ in: 	[evnt-name, f]
	\ out:	[evnt_flg, []]
	a:new 0 rot __ps_evnt_flg@ a:! 1 a:new a:! ; 

\ ----------------------------------
\ Store initial event data
: __ps_store_new	 SED: a a -- 
	\ in: 	[evnt-name, f]
	\				[f, []]
	\ out:	[evnt_flg, []]
	__ps_evnt_name@ __ps_store@ swap rot m:! drop ;

\ ----------------------------------
\ Register a new entry	
: __ps_reg_new	 SED: a --
	\ in: 	[evnt-name, f]
	\ out:	none
	dup __ps_make_evnt_data
	swap __ps_store_new ;

\ ========================================
\ Subscribe helper words
\
\ Retrieve the callback word
: __ps_evnt_callback@  SED: a -- w
	\ in: 	[w]
	\ out:	w
	1 a:@ nip ;

\ ========================================
\ Publish helper words
\
\ Retrieve the subscriber list
: __ps_sub_list@  SED: a -- a
	\ in: 	[w]
	\ out:	w
	\ [f,[w,w,..]]
	__ps_evnt_name@ __ps_store@ swap m:@ nip ;

\ ----------------------------------
\ Retrieve the event data	
: __ps_evnt_data@  SED: a -- *
	\ in: 	[w]
	\ out:	event-data
	1 a:@ nip ;

\ ========================================
\ Message handlers
\ ========================================

\ Initialise the p/s structure
: do_ps_init  SED: a --
	\ in: 	[]
	\ out:	none
	\
	\ Create the dictionary in a task var
	\ Form is as follows
	\ {"name": [f,[w1,w2,w3...]], "name1": [f,[w4,w5,w6...]], ...}
	drop {} "ps_s" t:! ;

\ ----------------------------------
\ Register a new event
: do_ps_reg	 SED: a --
	\ in: 	[evnt-name, f]
	\ out:	none
	\ data: [evnt-name, f] where f==true if dispatch on main thread
	dup >r
	__ps_exists? if
		\ Problem
		"The registration " r> __ps_evnt_name@ s:+ " already exists!" s:+ throw  
	else
		\ Create a new registration
		r> __ps_reg_new
	then ;

\ ----------------------------------
\ Subscribe to an event
: do_ps_sub	 SED: a --
	\ in: 	[event-name, w]
	\ out:	none
	
	dup >r
	__ps_exists? if
		\ Add a new subscriber to the event
		\ Get the callback array
		__ps_store@ r@ __ps_evnt_name@ m:@ nip
		\ Get the callback word array [f,[w,w, ..]]
		1 a:@ nip
		\ Append the new callback word to the array
		r@ __ps_evnt_callback@ a:push drop
	else
		\ Problem
		"No registration " r> __ps_evnt_name@ s:+ " to subscribe to!" s:+ throw 
	then rdrop ;

\ ----------------------------------
\ Dispatch to subscriber on main thread
\ Callee must consume 'data' on TOS
: __ps_main_thd_dispatch	  SED: m --
	\ in: 	{"cb" : w, "to" : w, "data" : Opaque}
	\ out:	none
	"data" m:@ swap "to" m:@ nip w:exec ;

\ ----------------------------------
\ Dispatch to subscriber
\ Callee must consume 'data' on TOS
: __ps__dispatch		  SED: n w -- 
	\ in: 	0: w - word to dispatch to
	\				1: T - true if dispatch on main thread
	\ out:	none
	nip >r
	1 pp@ if
		\ Dispatch on main thread
		\ Word to invoke on main thread
		{ "cb" : ' __ps_main_thd_dispatch }
		\ Word 'to' dispatch 'data' to
		\ Note we clone the data again to ensure no conflicts
		"to" r> m:! "data" p@ m:! clone nip
		g:do
	else
		\ Dispatch on this thread, no clone as ownership is this thread
		\ The subscriber callback must not dispatch again on another thread!
		p@ r> w:exec
	then ;

\ ----------------------------------
\ Publish an event	
: do_ps_pub	 SED: a --
	\ in: 	[event-name, event-data]
	\ out:	none
	dup >r
	__ps_exists? if
		\ Get the subscriber list and dispatch flag
		\ Push the dispatch flag to the p stack
		r@ __ps_sub_list@ a:open swap >p
		\ For each subscriber send data to the subscribers callback word
		\ Push the data to the p stack as we need to retain a copy
		r> __ps_evnt_data@ >p ' __ps__dispatch a:each drop
	else
		\ Problem
		"No registration " r> __ps_evnt_name@ s:+ " to publish to" s:+ throw 
	then 
	2 pndrop 
	\ Some recipients may never create maps and arrays and therefore the structures
	\ we pass along here may accumulate on the free pool and consume memory. 
	ns:m pool-clear ns:a pool-clear ;

\ ===============================================================================
\ PUBLIC
\ Public procedural interface, call from any thread
\ ===============================================================================

\ ----------------------------------	
\ Register a new event
\ All events must be registered before they can be used
\ Event names are just strings
: pubsub_register	 SED: T s -- 
	\ in:		s - event name 	
	\				f - true if to be dispatched on main thread else p/s thread
	\ out:	none
	a:new 0 rot a:! 1 rot a:!
	"P/S_TASK" ' do_ps_reg rot msg! ;
	
\ ----------------------------------
\ Initialise publish/subscribe system
: pubsub_init	SED: w --
	\ in: 	0: w - do_registrations	(call to do registrations for app namespace)
	\ out:	none
	>r
	\ Create and start the gen-server
	"P/S_TASK" t:curtask 2 ' gen_server t:task-n -1 sleep drop
	\ Initialise the server
	"P/S_TASK" ' do_ps_init a:new msg! 
	\ Register all events
	\ To keep pub_sub generic the registered events are part of the application and
	\ not part of the framework. This works by passing in the word to call to perform
	\ registrations. We then call this word passing the pubsub_regiater word to call
	\ to register each event. This mechanism prevents circular references reqiring
	\ defers and code refactoring.
	' pubsub_register r> w:exec ;

\ ----------------------------------
\ Terminate publish/subscribe system
: pubsub_term	SED: --
	\ in: 	none
	\ out:	none
	\ Note gen-server performs termination
	"P/S_TASK" ' gs_do_term a:new msg! ;

\ ----------------------------------
\ Subscribe to an event
: pubsub_subscribe	 SED: s w -- 
	\ in:		s - event name	
	\				w - callback word 	
	\ out:	none
	a:new 1 rot a:! 0 rot a:!
	"P/S_TASK" ' do_ps_sub rot msg! ;

\ ----------------------------------
\ Publish an event to subscribers
: pubsub_publish	 SED: s * -- 
	\ in:		* - event-data 
	\				s - event-name	
	\ out:	none
	a:new 1 rot a:! 0 rot a:!
	"P/S_TASK" ' do_ps_pub rot msg! 
	\ BC - 18.08 sleep required else fails quickly
	0.005 sleep ;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================
pub_sub_test @ #if
	: callback_wd_1	\ data
		"wd_1: " t:name@ s:+ " : " s:+ swap s:+ log ;

	: callback_wd_2	\ data
		"wd_2: " t:name@ s:+ " : " s:+ swap s:+ log ;

	: init_test
		' sdr:do_registrations fr:pubsub_init
		1 sleep
		sdr:UI_SMPL_RATE ' callback_wd_1 fr:pubsub_subscribe
		sdr:UI_NUM_RX ' callback_wd_1 fr:pubsub_subscribe
		sdr:UI_R1_FREQ ' callback_wd_1 fr:pubsub_subscribe
		sdr:SYS_SMPL_RATE ' callback_wd_2 fr:pubsub_subscribe
		sdr:SYS_NUM_RX ' callback_wd_2 fr:pubsub_subscribe
		sdr:SYS_R1_FREQ ' callback_wd_2 fr:pubsub_subscribe
	;

	: run_test
		"Run: " swap >s s:+ log
		sdr:UI_SMPL_RATE sdr:UI_SMPL_RATE fr:pubsub_publish
		sdr:UI_NUM_RX sdr:UI_NUM_RX fr:pubsub_publish
		sdr:UI_R1_FREQ sdr:UI_R1_FREQ fr:pubsub_publish
		sdr:SYS_SMPL_RATE sdr:SYS_SMPL_RATE fr:pubsub_publish
		sdr:SYS_NUM_RX sdr:SYS_NUM_RX fr:pubsub_publish
		sdr:SYS_R1_FREQ sdr:SYS_R1_FREQ fr:pubsub_publish
		0.05 sleep
		\ cr cr depth . " " . dstack st:len nip . " " . pdepth . cr
	;

	: run_tests
		' run_test 1 5000 loop
		0.2 sleep
	;

	param_st_alloc
	init_test
	run_tests
	fr:pubsub_term 
	\ Wait for all tasks to exit
	fr:gs_wait_all

	\ allow log to flush...
	0.2 sleep
	bye
#then
	