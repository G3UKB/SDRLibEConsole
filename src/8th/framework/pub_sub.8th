(*
	pub_sub.8th
 
  Publish/Subscribe system
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ Up the q a little
1000 t:def-queue

\ ========================================
\ Testing only
false var, pub_sub_test

pub_sub_test @ #if
	\ needs debug/sed
	\ true SED-CHECK
	\ Includes
	"param_st.8th"  f:include
	"task_man.8th"  f:include
	"registrations.8th" f:include
#then
\ ========================================

\ Set namespace
ns: fr

\ =============================================================================================
\ Publish / Subscribe gen_server handlers
\ ========================================
\ General Helpers
\
\ Return the data element
: data@	 SED: m -- *
	\ in: 	{ "type" : ... , "data" : Any }
	\ out:	Opaque data
	"data" m:@ nip ;

\ ----------------------------------
\ Return the pub/sub store	
: store@	 SED: -- m
	\ in: 	none
	\ out:	pub/sub store
	"ps_s" t:@ ;

\ ----------------------------------	
\ Retrieve the event name
: evnt_name@  SED: m -- s
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\ out:	evnt-name
	data@ 0 a:@ nip ;
	
\ ========================================
\ Registration helpers
\
\ Retrieve the event flag
: evnt_flg@  SED: m -- T
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\ out:	flag
	data@ 1 a:@ nip ;	

\ ----------------------------------
\ Does the event name already exist
: ps_exists?	 SED: m -- F
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\ out:	flag
	evnt_name@ store@ swap m:exists? nip ;

\ ----------------------------------
\ Return default event data
: ps_make_evnt_data	 SED: m -- a
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\ out:	[evnt_flg, []]
	a:new 0 rot evnt_flg@ a:! 1 a:new a:! ; 

\ ----------------------------------
\ Store initial event data
: ps_store_new	 SED: a m -- 
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\				[f, []]
	\ out:	[evnt_flg, []]
	evnt_name@ store@ swap rot m:! drop ;

\ ----------------------------------
\ Register a new entry	
: ps_reg_new	 SED: m --
	\ in: 	{ "type" : ... , "data" : [evnt-name, f] }
	\ out:	none
	dup ps_make_evnt_data
	swap ps_store_new ;

\ ========================================
\ Subscribe helpers
\
\ Retrieve the callback word
: evnt_callback@  SED: m -- w
	\ in: 	{ "type" : ... , "data" : [w] }
	\ out:	w
	data@ 1 a:@ nip ;

\ ========================================
\ Publish helpers
\
\ Retrieve the subscriber list
: sub_list@  SED: m -- a
	\ in: 	{ "type" : ... , "data" : [w] }
	\ out:	w
	\ [f,[w,w,..]]
	evnt_name@ store@ swap m:@ nip ;

\ ----------------------------------
\ Retrieve the event data	
: evnt_data@  SED: m -- *
	\ in: 	{ "type" : ... , "data" : [w] }
	\ out:	event-data
	"data" m:@ nip 1 a:@ nip ;

\ ========================================
\ Message handlers
\ Initialise the p/s structure
: do_init  SED: m --
	\ in: 	{ "type" : "init" }
	\ out:	none
	\
	\ Create the dictionary in a task var
	\ Form is as follows
	\ {"name": [f,[w1,w2,w3...]], "name1": [f,[w4,w5,w6...]], ...}
	drop {} "ps_s" t:! ;

\ ----------------------------------
\ Register a new event
: do_reg	 SED: m --
	\ in: 	{ "type" : "reg" , "data" : [evnt-name, f] }
	\ out:	none
	\ data: [evnt-name, f] where f==true if dispatch on main thread
	dup >r
	ps_exists? if
		\ Problem
		"The registration " r> evnt_name@ s:+ " already exists!" s:+ throw  
	else
		\ Create a new registration
		r> ps_reg_new
	then ;

\ ----------------------------------
\ Subscribe to an event
: do_sub	 SED: m --
	\ in: 	{ "type" : "sub" , "data" : [event-name, w]}
	\ out:	none
	dup >r
	ps_exists? if
		\ Add a new subscriber to the event
		\ Get the callback array
		store@ r@ evnt_name@ m:@ nip
		\ Get the callback word array [f,[w,w, ..]]
		1 a:@ nip
		\ Append the new callback word to the array
		r@ evnt_callback@ a:push drop
	else
		\ Problem
		"No registration " r> evnt_name@ s:+ " to subscribe to!" s:+ throw 
	then ;

\ ----------------------------------
\ Dispatch to subscriber on main thread
\ Callee must consume 'data' on TOS
: main_thd_dispatch	  SED: m --
	\ in: 	{"cb" : w, "to" : w, "data" : Opaque}
	\ out:	none
	"data" m:@ swap "to" m:@ nip w:exec ;

\ ----------------------------------
\ Dispatch to subscriber
\ Callee must consume 'data' on TOS
: pubsub_dispatch		  SED: n w -- 
	\ in: 	0: w - word to dispatch to
	\				1: T - true if dispatch on main thread
	\ out:	none
	nip >r
	1 pp@ if
		\ Dispatch on main thread
		\ Word to invoke on main thread
		{ "cb" :' main_thd_dispatch } const
		\ Word 'to' dispatch 'data' to
		\ Note we clone the data again to ensure no conflicts
		"to" r> m:! "data" p@ const m:!
		g:do
	else
		\ Dispatch on this thread, no clone as ownership is this thread
		\ The subscriber callback must not dispatch again on another thread!
		p@ r> w:exec
	then ;

\ ----------------------------------
\ Publish an event	
: do_pub	 SED: m --
	\ in: 	{ "type" : pub , "data" : [event-name, event-data]}
	\ out:	none
	dup >r
	ps_exists? if
		\ Get the subscriber list and dispatch flag
		\ Push the dispatch flag to the p stack
		r@ sub_list@ a:open swap >p
		\ For each subscriber send data to the subscribers callback word
		\ Push the data to the p stack as we need to retain a copy
		r> evnt_data@ >p ' pubsub_dispatch a:each drop
	else
		\ Problem
		"No registration " r> evnt_name@ s:+ " to publish to" s:+ throw 
	then 
	2 pndrop ;

\ ===============================================================================
\ Main code may be called from any thread
\ ===============================================================================

\ ----------------------------------	
\ Register a new event
\ All events must be registered before they can be used
\ Event names are just strings
: pubsub_register	 SED: T s -- 
	\ in:		s - event name 	
	\				f - true if to be dispatched on main thread else p/s thread
	\ out:	none
	a:new 0 rot a:! 1 rot a:!
	"P/S_TASK" ' do_reg rot msg! ;

\ ----------------------------------	
\ UI and SYS registrations
: do_registrations	SED: --
	\ in:		none
	\ out:	none
	\
	\ true means dispatch on main thread
	\ false means dispatch on p/s thread
	\
	\ Options events
	\ UI subscribers
	true UI_SMPL_RATE pubsub_register
	true UI_NUM_RX pubsub_register
	true UI_BLK_SZ pubsub_register
	true UI_INPUT_SRC pubsub_register
	true UI_INPUT_DEV pubsub_register
	true UI_OUTPUT_SINK pubsub_register
	true UI_RECEIVER pubsub_register
	true UI_OUTPUT_DEV pubsub_register
	true UI_CHANNEL pubsub_register
	true UI_AVMODE pubsub_register
	true UI_AVOVER pubsub_register
	true UI_WINTYPE pubsub_register
	true UI_FFT_SIZE pubsub_register
	true UI_TUNE_LEVEL pubsub_register
	\ System subscribers
	false SYS_SMPL_RATE pubsub_register
	false SYS_NUM_RX pubsub_register
	false SYS_BLK_SZ pubsub_register
	false SYS_INPUT_SRC pubsub_register
	false SYS_INPUT_DEV pubsub_register
	false SYS_OUTPUT_SINK pubsub_register
	false SYS_RECEIVER pubsub_register
	false SYS_OUTPUT_DEV pubsub_register
	false SYS_CHANNEL pubsub_register
	false SYS_AVMODE pubsub_register
	false SYS_AVOVER pubsub_register
	false SYS_WINTYPE pubsub_register
	false SYS_FFT_SIZE pubsub_register
	false SYS_TUNE_LEVEL pubsub_register
	false SYS_AUDIO_ROUTE pubsub_register

	\ Radio RX events
	\ UI subscribers
	true UI_R1_FREQ pubsub_register
	true UI_R2_FREQ pubsub_register
	true UI_R3_FREQ pubsub_register
	true UI_R1_MODE pubsub_register
	true UI_R2_MODE pubsub_register
	true UI_R3_MODE pubsub_register
	true UI_R1_FILT pubsub_register
	true UI_R2_FILT pubsub_register
	true UI_R3_FILT pubsub_register
	true UI_R1_AGC pubsub_register
	true UI_R2_AGC pubsub_register
	true UI_R3_AGC pubsub_register
	true UI_R_ATTN pubsub_register
	true UI_R_HF_PRE pubsub_register
	true UI_R_6M_PRE pubsub_register
	true UI_R1_AFGAIN pubsub_register
	true UI_R2_AFGAIN pubsub_register
	true UI_R3_AFGAIN pubsub_register
	\ System subscribers
	false SYS_R1_FREQ pubsub_register
	false SYS_R2_FREQ pubsub_register
	false SYS_R3_FREQ pubsub_register
	false SYS_R1_MODE pubsub_register
	false SYS_R2_MODE pubsub_register
	false SYS_R3_MODE pubsub_register
	false SYS_TX_MODE pubsub_register
	false SYS_R1_FILT pubsub_register
	false SYS_R2_FILT pubsub_register
	false SYS_R3_FILT pubsub_register
	false SYS_R1_AGC pubsub_register
	false SYS_R2_AGC pubsub_register
	false SYS_R3_AGC pubsub_register
	false SYS_R_ATTN pubsub_register
	false SYS_R_HF_PRE pubsub_register
	false SYS_R_6M_PRE pubsub_register
	false SYS_R1_AFGAIN pubsub_register
	false SYS_R2_AFGAIN pubsub_register
	false SYS_R3_AFGAIN pubsub_register

	\ Radio TX events
	\ UI subscribers
	true UI_DUPLEX pubsub_register
	true UI_RFGAIN pubsub_register
	true UI_MICGAIN pubsub_register
	true UI_TX_FREQ pubsub_register
	true UI_TX_MODE pubsub_register
	true UI_TX_FILT pubsub_register
	\ System subscribers
	false SYS_MOX pubsub_register 
	false SYS_DUPLEX pubsub_register
	false SYS_RFGAIN pubsub_register
	false SYS_MICGAIN pubsub_register
	false SYS_TX_FREQ pubsub_register
	false SYS_TX_FILT pubsub_register

	\ Window system events 
	false SYS_R1_DISP_UPDT pubsub_register
	false SYS_R2_DISP_UPDT pubsub_register
	false SYS_R3_DISP_UPDT pubsub_register

	\ End of init
	false SYS_RUN_STATE pubsub_register
;

\ ----------------------------------
\ Initialise publish/subscribe system
: pubsub_init	SED: --
	\ in: 	none
	\ out:	none
	\ Create and start the gen-server
	"P/S_TASK" 1 ' gen_server t:task-n -1 sleep drop
	\ Initialise the server
	"P/S_TASK" ' do_init a:new msg! 
	\ Register all events
	do_registrations ;

\ ----------------------------------
\ Terminate publish/subscribe system
: pubsub_term	SED: --
	\ in: 	none
	\ out:	none
	"P/S_TASK" ' do_term a:new msg! ;

\ ----------------------------------
\ Subscribe to an event
: pubsub_subscribe	 SED: s w -- 
	\ in:		s - event name	
	\				w - callback word 	
	\ out:	none
	a:new 1 rot a:! 0 rot a:!
	"P/S_TASK" ' do_sub rot msg! ;

\ ----------------------------------
\ Publish an event to subscribers
: pubsub_publish	 SED: s * -- 
	\ in:		* - event-data 
	\				s - event-name	
	\ out:	none
	a:new 1 rot a:! 0 rot a:!
	"P/S_TASK" ' do_pub rot msg! ;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ Testing
\ ===============================================================================
pub_sub_test @ #if
	: callback_wd_1	\ data
		"wd_1: " t:name@ s:+ " : " s:+ swap s:+ log ;

	: callback_wd_2	\ data
		"wd_2: " t:name@ s:+ " : " s:+ swap s:+ log ;

	: init_test
		fr:pubsub_init
		1 sleep
		fr:UI_SMPL_RATE ' callback_wd_1 fr:pubsub_subscribe
		fr:UI_NUM_RX ' callback_wd_1 fr:pubsub_subscribe
		fr:UI_R1_FREQ ' callback_wd_1 fr:pubsub_subscribe
		fr:SYS_SMPL_RATE ' callback_wd_2 fr:pubsub_subscribe
		fr:SYS_NUM_RX ' callback_wd_2 fr:pubsub_subscribe
		fr:SYS_R1_FREQ ' callback_wd_2 fr:pubsub_subscribe
	;

	: run_test
		"Run: " swap >s s:+ log
		fr:UI_SMPL_RATE fr:UI_SMPL_RATE fr:pubsub_publish
		fr:UI_NUM_RX fr:UI_NUM_RX fr:pubsub_publish
		fr:UI_R1_FREQ fr:UI_R1_FREQ fr:pubsub_publish
		fr:SYS_SMPL_RATE fr:SYS_SMPL_RATE fr:pubsub_publish
		fr:SYS_NUM_RX fr:SYS_NUM_RX fr:pubsub_publish
		fr:SYS_R1_FREQ fr:SYS_R1_FREQ fr:pubsub_publish
		0.05 sleep
		\ cr cr depth . " " . dstack st:len nip . " " . pdepth . cr
	;

	: run_tests
		' run_test 1 5000 loop
		0.2 sleep
	;

	param_st_alloc
	init_test
	run_tests
	fr:pubsub_term 
	\ Wait for all tasks to exit
	fr:wait_all

	\ allow log to flush...
	0.2 sleep
	bye
#then
	