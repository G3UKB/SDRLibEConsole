(* 
	transient
 
  Transient tasks to support connector
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ Set namespace
ns: sdr

(*
	Transient tasks are tasks started that are normal permanent gen-server tasks but spend
	most time sitting on the gen-server q. They are messaged usually from GUI event procs to
	perform functions that may have a response. Responses cannot be sent to the main thread
	for some reason that crashes. If the response is required by the main thread then it is
	send asychronously by a g:do which is the only way to communicate from a task back to
	the main thread.
*)

\ ===============================================================================
\ Transient task execution words

\ Return start pattern for displays
: conn_pat_rx1	SED: --
	true false false ;
	
: conn_pat_rx2	SED: --
	true true false ;
	
: conn_pat_rx3	SED: --
	true true true ;
	
\ ----------------------------------
\ Try to connect and start the server
: conn_try_connect	SED: T -- 
	\ in: 		0: T - if true then run radio if possible else just give a status
	\ out:		none
	\ state: 	updated for GUI to interrogate
	
	conn_poll if
		"SDRLibE server is on-line..." log
		if
			\ Set server running
			true st_svr_running!
			\ Try discover to see if we have radio hardware
			conn_discover if
				\ We have radio hardware
				"Radio hardware found!" log
				\ Set state to on-line
				true st_rad_online!
				\ Must set num rx before server start
				st_rad_num_rx@ conn_set_num_rx "NumRX: " swap >s s:+ log
				\ Send events that are required before server startup
				\ Specifically audio routes
				option_model_pre_sys_evnts
				0.1 sleep
				\ Start the server processes (this starts the DSP etc)
				conn_start_server "Server start: " swap >s s:+ log
				\ Now update the server with the current model state
				option_model_sys_evnts
				app_model_sys_evnts				
				\ Set display frequency to 100ms period
				100 svr_evnt_set_disp_period not if "Failed to set display period!" throw then
				\ Get the start pattern for the number of radios
				[ ' conn_pat_rx1 , ' conn_pat_rx2 , ' conn_pat_rx3 ] st_rad_num_rx@ n:1- caseof
				svr_evnt_set_disp_state not if "Failed to enable displays!" throw then			
			else
				"****" log
				"No radio hardware found!" log
				"To try again use the 'Discover' button." log
				"****" log
			then
		then
	else
		\ No server or no network connectivity to the server
		"****" log
		"The SDRLibE Server is not running!" log 
		"To try again use the 'Discover' button." log
		"****" log
		false
	then ;

\ ----------------------------------
\ Try to start/stop the radio hardware
: conn_try_radio	SED: T --
	\ in: 		0: T - if true then start radio else stop radio
	\ out:		none
	\ state: 	updated for GUI to interrogate
	if
		\ Try to start the radio
		NO_WBS conn_start_radio if
			\ Set radio running flag
			true st_rad_running!
			"ACK from start radio" log
		else
			"****" log
			"Radio did not start!" log
			"To try again use the 'Start' button." log
			"****" log
		then
	else
		\ Try to stop the radio
		conn_stop_radio if
			\ Set radio running flag
			"ACK from stop radio" log
			false st_rad_running!
		else
			"****" log
			"Radio did not stop" log
			"To try again use the 'Stop' button." log
			"****" log
		then
	then ;

\ ----------------------------------
\ Call a miscellaneous word and optionally check the response
\ Normally a message from a GUI event proc. The called word can
\ do g:do to send an async response to the main thread.
\ The called word can be a procedural interface to another gen-server task.
: conn_call	SED: a --
	\ in: 	0: T - true if twoway (i.e. response)
	\				1: w - word to call
	\				2: * - opaque data
	\ out:	none
	a:open
	if
		w:exec
		"Response from call" swap >s s:+ log
	else
		w:exec
	then ;

\ ===============================================================================
\ Initialisation and destruction

\ ----------------------------------
\ Start transient task
: con_transient_init SED: --
	"TRANSIENT_TASK" t:curtask 2 ' fr:gen_server t:task-n -1 sleep drop
;

\ ----------------------------------
\ Terminate transient task
: conn_transient_term	SED: --
	\ Ask the task to exit
	"TRANSIENT_TASK" ' fr:gs_do_term a:new fr:msg! ;
	
\ ========================================
\ Reset namespace
ns: user