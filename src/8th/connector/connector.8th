(* 
	connector.8th
 
  Client connector to SDRLibEConnector server
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

\ ========================================
\ Testing only
false var, connector_test_1
true var, connector_test_2
connector_test_1 @ #if

	\ includes
	"../framework/param_st.8th" f:include
	"../framework/gen_server.8th" f:include
	"../framework/struct_manip.8th" f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
	"../common/radio_defs.8th" f:include
	"../framework/pub_sub.8th"  f:include

	\ needs debug/sed
	\ true SED-CHECK
	\ false log-async
	
	\ Test cases simulation words start
	\ Overwrite words that are needed for simulation testing 
	: net:sendto	\ net ai buf flags -- net #sent
		drop s:len nip nip ;	\ Good case
		\ drop 10 nip nip ;		\ Bad case

	: net:wait	\ net read? msecs -- net f
		2drop true ;								\ Read ready
		\ 1000 / sleep drop false ;	\ Timeout

	: ack_resp \ -- ack
		{"resp":"ACK"} ;

	: audio_resp \ -- audio-resp
		{"outputs": [{},{"api":"someapi" , "name":"somedev"}] } ;

	: net:recvfrom \ net buf flags -- net addr port buf #recv | net null
		\ 2drop "127.0.0.1" 10010 ack_resp >json s:len ; 	\ Good case
		2drop "127.0.0.1" 10010 audio_resp >json s:len ; 	\ Good case
		\ 2drop null ;																		\ Bad case

#then
connector_test_2 @ #if

	\ includes
	"../framework/param_st.8th" f:include
	"../framework/gen_server.8th" f:include
	"../framework/struct_manip.8th" f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
	"../common/radio_defs.8th" f:include
	"../framework/pub_sub.8th"  f:include

	\ needs debug/sed
	\ true SED-CHECK
	\ false log-async
#then
\ =========================================

(*
	GEN_SERVER application -
	The connector drives the SDRLibE/connector executable via a JSON UDP interface. This enables
	distribution if required and also makes it a managed server which will execute on its own
	once its setup is complete which could be a command line client or a GUI client. It is also
	much more ameanable to multi-language implementation as the interface remains the same on the
	client side rather than an implementation for each language ffi implementation. 
*)

\ Set namespace
ns: sdr

\ ===============================================================================
\ PRIVATE
\ Convention: private words start: 		__conn_
\ 						message handlers start: do_conn_
\							event handlers start: 	__conn_evnt_
\ ===============================================================================

\ Initialisation
\ Create UDP socket
: __conn_create_socket	SED: --
	\ in: 	none
	\ out:	none
	{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket "udp_cmd_sock" t:! ;
	
\ Get command socket
: __conn_cmd_sock@	SED: -- net
	\ in: 	none
	\ out:	s0 - command socket
	"udp_cmd_sock" t:@ ;

\ ===============================================================================
\ Buffers
\ Create response buffer
: __conn_create_resp_buf	SED: --
	\ in: 	none
	\ out:	none
	5000 b:new 0x0 b:fill "b_resp_buffer" t:! ;

\ ----------------------------------	
\ Get response buffer
: __conn_resp_buf@	SED: --
	\ in: 	none
	\ out:	none	
	"b_resp_buffer" t:@ ;
	
\ ===============================================================================
\ Json encoded request messages	
: __conn_push_one_param 	SED: * a -- 
	\ in:		0: m - empty message
	\				1: * - p1
	\ out:	none
	"params" m:@ a:clear rot a:push drop ;

\ ----------------------------------
: __conn_push_two_param 	SED: * * a -- 
	\ in:		0: m - empty message
	\				1: * - p1
	\				2: * - p2
	\ out:	none
	"params" m:@ a:clear rot a:push rot a:push drop ;
	
\ ========================================
\ Simple messages with zero-two parameters, same SED: ... -- s (a Json encoded string)
: __conn_discover_msg { "cmd" : "radio_discover" , "params" : [] } >json ;
: __conn_server_start_msg { "cmd" : "server_start" , "params" : [] } >json ;
: __conn_enum_inputs_msg { "cmd" : "enum_inputs" , "params" : [] } >json ;
: __conn_enum_outputs_msg { "cmd" : "enum_outputs" , "params" : [] } >json ;	
: __conn_radio_start_msg { "cmd" : "radio_start" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_freq_msg { "cmd" : "set_rx1_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_freq_msg { "cmd" : "set_rx2_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_freq_msg { "cmd" : "set_rx3_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_tx_freq_msg { "cmd" : "set_tx_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_mode_msg { "cmd" : "set_rx1_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_mode_msg { "cmd" : "set_rx2_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_mode_msg { "cmd" : "set_rx3_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_tx_mode_msg { "cmd" : "set_tx_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_filt_msg { "cmd" : "set_rx1_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_r2_filt_msg { "cmd" : "set_rx2_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_r3_filt_msg { "cmd" : "set_rx3_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_tx_filt_msg { "cmd" : "set_tx_filter" , "params" : [] } __conn_push_two_param >json ;

\ Complex messages
\ ----------------------------------	
: __conn_default_route_msg	SED: s s -- s
	\ in:		0: s - audio api i.e. "MME"
	\				1: s - audio device name string
	\ out:	0: s - json encoded default route message
	>r >r { "cmd" : "set_audio_route" , "params" : [1, "LOCAL", 1, "", "", "BOTH"] }
	"params" m:@ 3 r> a:! 4 r> a:! drop >json ;
	
\ ===============================================================================
\ Net

\ ========================================
\ Address management
\ Return the command port
: __conn_cmd_port	SED: -- n
	\ in: 	none
	\ out:	s0 - cmd port
	10010 ;

\ ----------------------------------	
\ Return the display data receiver 1 port	
: __conn_data_1_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 1 port
	10011 ;

\ ----------------------------------	
\ Return the display data receiver 2 port
: __conn_data_2_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 2 port
	10012 ;

\ ----------------------------------	
\ Return the display data receiver 3 port
: __conn_data_3_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 3 port
	10013 ;
	
\ ----------------------------------	
\ Return the command address info
: __conn_cmd_addr		SED: -- X
	\ in: 	none
	\ out:	s0 - cmd address info
	"127.0.0.1" __conn_cmd_port net:getaddrinfo ;
	
\ ----------------------------------	
\ Return the display data receiver 1 address info	
: __conn_data_1_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 1 address info
	"127.0.0.1" __conn_data_1_port net:getaddrinfo ;

\ ----------------------------------	
\ Return the display data receiver 2 address info		
: __conn_data_2_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 2 address info
	"127.0.0.1" __conn_data_2_port net:getaddrinfo ;

\ ----------------------------------	
\ Return the display data receiver 3 address info	
: __conn_data_3_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 3 address info
	"127.0.0.1" __conn_data_3_port net:getaddrinfo ;

\ ========================================
\ Message send/receive

\ Send given command
: __conn_send_cmd_msg	SED: s --
	\ in: 	so - json encoded message string
	\ out:	s0 - none
	s:len >r
	__conn_cmd_sock@ __conn_cmd_addr rot 0 net:sendto nip
	r> n:= not if "Short send!" log then ;

\ ----------------------------------	
\ Wait for read data available from cmd socket
: __conn_net_wait_recv_cmd	SED:  -- net T
	\ in: 	none
	\ out:	s0 - true if wait successful
	\				s1 - the target socket
	__conn_cmd_sock@ true 5000 net:wait ;

\ ----------------------------------	
\ Receive data from the given socket
: __conn_recv_from	SED:  net -- m T
	\ in: 	s0 - socket
	\ out:	s0 - true if receive successful
	\ pre: 	read data ready condition true
	__conn_resp_buf@ 0 net:recvfrom null? if 
		"Error in read from device!" throw
	else
		drop nip nip nip json>
	then ;

\ ----------------------------------			
\ Wait for and read cmd response
: __conn_wait_resp_with_timeout	SED:  -- m T
	\ in: 	none
	\ out:	0: T - true if response received
	\				1: m - the response structure (map in this case)
	__conn_net_wait_recv_cmd if
		__conn_recv_from
	else
		"Timeout waiting for response from device!" throw
	then ;
	
\ ===============================================================================
\ Protocol words
\ Return the audio info for all output devices
: __conn_get_audio_output_info	SED: -- m T
	\ in: 	none
	\ out:	s0 - true if successful
	\ out:	s1 - the audio info map
	__conn_enum_outputs_msg __conn_send_cmd_msg __conn_wait_resp_with_timeout ;

\ ----------------------------------	
\ Return the default route audio parameters
: __conn_get_default_route	SED:  -- s s
	\ in: 	none
	\ out:	s0 - the audio api
	\				s1 - the audio device
	__conn_get_audio_output_info
	\ Return api and dev for the default device
	\ Note, we should select for this aka gui interface
	"outputs" m:@ nip 1 a:@ nip
	"api" m:@ swap "name" m:@ nip ; 
	

\ ========================================
\ Message handlers
\ ========================================

\ ========================================
\ General management
\ Initialise the connector at task level
: do_conn_init	SED: a --
	\ in: 	message
	\ out:	none
	drop 
	__conn_create_socket 
	__conn_create_resp_buf ;

\ ----------------------------------
\ Run SOD
: do_conn_start_of_day	SED: a --
	\ in: 	message
	\ out:	none
	drop ;

\ ----------------------------------
\ Close the app model at task level
: do_conn_close	SED: m --
	\ in: 	message
	\ out:	none
	drop ;

\ ========================================
\ Do response
: __con_do_response	SED: -- 
	__conn_wait_resp_with_timeout
	fr:response! ;

\ Do exchange
: __con_do_exchange	SED: -- 
	__conn_send_cmd_msg  __con_do_response ;

\ ========================================
\ Basic radio functions
\ Execute discover protocol
: do_conn_discover	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_discover_msg __con_do_exchange ;

\ ----------------------------------
\ Set a default route for RX1 to Speaker output both channels
: do_conn_set_default_route	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_get_default_route __conn_default_route_msg __con_do_exchange ;

\ ----------------------------------
\ Start the server 
: do_conn_start_server	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_server_start_msg __con_do_exchange ;

\ ----------------------------------
\ Start the radio
: do_conn_start_radio	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\				1: T - true if start WBS
	\ out: 	q: * - "Timeout" or response data
	swap __conn_radio_start_msg __con_do_exchange ;

\ ========================================
\ Receiver functions
\ Set R1 frequency
: do_conn_r1_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_freq_msg __con_do_exchange ;

\ ----------------------------------
\ Set R2 frequency
: do_conn_r2_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_freq_msg __con_do_exchange ;

\ ----------------------------------
\ Set R3 frequency
: do_conn_r3_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_freq_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set TX frequency
: do_conn_tx_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - TX freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_tx_freq_msg __con_do_exchange ;

\ ----------------------------------
\ Set R1 mode
: do_conn_r1_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_mode_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set R2 mode
: do_conn_r2_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_mode_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set R3 mode
: do_conn_r3_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_mode_msg __con_do_exchange ;

\ ----------------------------------
\ Set R1 filter
: do_conn_r1_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 filter high
	\				2: s - R1 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot __conn_r1_filt_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set R2 filter
: do_conn_r2_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 filter high
	\				2: s - R2 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot  __conn_r2_filt_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set R3 filter
: do_conn_r3_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 filter high
	\				2: s - R3 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot  __conn_r3_filt_msg __con_do_exchange ;
	
\ ----------------------------------
\ Set TX filter
: do_conn_tx_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - TX filter high
	\				2: s - TX filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot  __conn_tx_filt_msg __con_do_exchange ;

\ ===============================================================================
\ PUBLIC
\ Public procedural interface, call from any thread
\ ===============================================================================

\ ----------------------------------
\ Execute discover protocol
: conn_discover	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_discover rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Set a default route for RX1 to Speaker output both channels
: conn_set_default_route	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_set_default_route rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Start the server 
: conn_start_server	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_start_server rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Start the radio
: conn_start_radio	SED: n -- *
	\ in: 	0: n - 1 if start WBS
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_start_radio rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Freq change
: conn_r1_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_freq rot fr:msg! 
	fr:response@ ;
	
: conn_r2_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	a:new swap a:push  fr:+sender
	"Connector_TASK" ' do_conn_r2_freq rot fr:msg! 
	fr:response@ ;
	
: conn_r3_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	a:new swap a:push  fr:+sender
	"Connector_TASK" ' do_conn_r3_freq rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Mode change
: conn_r1_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_mode rot fr:msg! 
	fr:response@ ;

: conn_r2_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_mode rot fr:msg! 
	fr:response@ ;
	
: conn_r3_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_mode rot fr:msg! 
	fr:response@ ;

: conn_tx_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_tx_mode rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Filter change
: conn_r1_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_filter rot fr:msg! 
	fr:response@ ;
	
: conn_r2_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_filter rot fr:msg! 
	fr:response@ ;
	
: conn_r3_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_filter rot fr:msg! 
	fr:response@ ;
	
: conn_tx_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_tx_filter rot fr:msg! 
	fr:response@ ;

\ ===============================================================================
\ EVENT HANDLERS for Publish/Subscribe system
\ Never call directly, only via pubsub_publish

\ Not implemented subscribe
: __conn_not_implemented	SED: * --
	"Not implemented!" log ;

\ ----------------------------------
\ Decode response
: __conn_evnt_resp SED: m s --
	\ in:		0: s - failure message
	\				1: m - respone {"resp" : value }
	\ out: 	none
	\ Throws exception on error
	swap "resp" m:@ nip "NAK" s:= if
		"Server 'NAK' from [" swap s:+ "]" s:+ throw
	then drop ;

\ ----------------------------------
\ Frequency update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_freq SED: m --
	"freq" m:@ conn_r1_freq "r1 frequency" __conn_evnt_resp ;
	
: __conn_evnt_r2_freq SED: m --
	"freq" m:@ conn_r2_freq "r2 frequency" __conn_evnt_resp ;
	
: __conn_evnt_r3_freq SED: m --
	"freq" m:@ conn_r3_freq "r3 frequency" __conn_evnt_resp ;

\ ----------------------------------
\ Mode update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_mode SED: m --
	"mode" m:@ conn_r1_mode "r1 mode" __conn_evnt_resp ;
	
: __conn_evnt_r2_mode SED: m --
	"mode" m:@ conn_r2_mode "r2 mode" __conn_evnt_resp ;
	
: __conn_evnt_r3_mode SED: m --
	"mode" m:@ conn_r3_mode "r3 mode" __conn_evnt_resp ;

\ ----------------------------------
\ Filter update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_filter SED: m --
	"filter" m:@ 
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r1_filter "r1 filter" __conn_evnt_resp ;
	
: __conn_evnt_r2_filter SED: m --
	"filter" m:@
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r2_filter "r2 filter" __conn_evnt_resp ;
	
: __conn_evnt_r3_filter SED: m --
	"filter" m:@
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r3_filter "r3 filter" __conn_evnt_resp ;
	
\ ===============================================================================
\ INITIALISATION and TERMINATION

\ Subscribe to system events that need to be forwarded to the server
: __conn_subscribe	SED: --
	SYS_R1_FREQ ' __conn_evnt_r1_freq fr:pubsub_subscribe
	SYS_R2_FREQ ' __conn_evnt_r2_freq fr:pubsub_subscribe
	SYS_R3_FREQ ' __conn_evnt_r3_freq fr:pubsub_subscribe
	SYS_R1_MODE ' __conn_evnt_r1_mode fr:pubsub_subscribe
	SYS_R2_MODE ' __conn_evnt_r2_mode fr:pubsub_subscribe
	SYS_R3_MODE ' __conn_evnt_r3_mode fr:pubsub_subscribe
	SYS_R1_FILT ' __conn_evnt_r1_filter fr:pubsub_subscribe
	SYS_R2_FILT ' __conn_evnt_r2_filter fr:pubsub_subscribe
	SYS_R3_FILT ' __conn_evnt_r3_filter fr:pubsub_subscribe
	SYS_R1_AGC ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R2_AGC ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R3_AGC ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R_ATTN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R_HF_PRE ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R_6M_PRE ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R1_AFGAIN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R2_AFGAIN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R3_AFGAIN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_MOX ' __conn_not_implemented fr:pubsub_subscribe
	SYS_DUPLEX ' __conn_not_implemented fr:pubsub_subscribe
	SYS_RFGAIN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_MICGAIN ' __conn_not_implemented fr:pubsub_subscribe
	SYS_TX_FREQ ' __conn_not_implemented fr:pubsub_subscribe
	SYS_TX_MODE ' __conn_not_implemented fr:pubsub_subscribe
	SYS_TX_FILT ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R1_DISP_UPDT ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R2_DISP_UPDT ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R3_DISP_UPDT ' __conn_not_implemented fr:pubsub_subscribe
	SYS_RUN_STATE ' __conn_not_implemented fr:pubsub_subscribe ;
	
\ ----------------------------------
\ Module initialisation
: conn_init	SED: --
	\ in: 	none
	\ out:	none
	\ Do subscription
	__conn_subscribe
	\ Create the connector gen-server
	"Connector_TASK" t:curtask 2 ' fr:gen_server t:task-n -1 sleep drop
	\ Ask the connector to initialise itself
	"Connector_TASK" ' do_conn_init a:new fr:msg!
	"Connector initialised sent" log
	"Connector_TASK" ' do_conn_start_of_day a:new fr:msg! ;

\ ----------------------------------
\ Module close
: conn_term	SED: --
	\ in: 	none
	\ out:	none
	\ Tidy close the connector
	"Connector_TASK" ' do_conn_close a:new fr:msg!
	2.0 sleep
	\ Ask the connector to exit
	"Connector_TASK" ' fr:gs_do_term a:new fr:msg! ;
	
\ ========================================
\ Reset namespace
ns: user


\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

\ ========================================
\ Test 1 - run all words with simulation.
connector_test_1 @ #if

	\ The test cases exercise each word on all paths and use the SED checker to establish
	\ correct stack behaviour. Some words may use words that require external calls and possibly
	\ expect external data. These are simulated by an overwrite of those words and the simulated
	\ word then behaves as closely as possible to the actual word. These words are at the beginning
	\ of the module as they need to be compiled first.	
	: test_cases
		\ Basic words with no dependencies
		resp_buffer "Buffer: " . b:len . drop cr
		discover_msg "Discover: " . . cr
		server_start_msg "Server start: " . . cr
		0 radio_start_msg "Radio start: " . . cr
		enum_outputs_msg "Enum outputs: " . . cr
		"some api" "some_dev" default_route_msg "Default route: " . . cr
		get_default_route "Get default route: " . cr
		cmd_port "Cmd port: " . . cr
		data_1_port "Data_1_port port: " . . cr
		data_2_port "Data_2_port port: " . . cr
		data_3_port "Data_3_port port: " . . cr
		cmd_addr "Cmd addr: " . . cr
		data_1_addr "Data_1_addr addr: " . . cr
		data_2_addr "Data_2_addr addr: " . . cr
		data_3_addr "Data_3_addr addr: " . . cr
		\ Words with dependencies
		discover_msg send_cmd_msg "Send discover message" . cr
		net_wait_recv_cmd "Wait for read data: " . . cr drop
		cmd_sock recv_from "Read: " . . " Data: " . . cr
		wait_resp_with_timeout "Response: " . . " Data: " . . cr ;
		
	cr cr "Running test cases..." . cr cr
	test_cases
	"Done test cases" . cr
	bye
#then

\ ========================================
\ Test 2 - basic script to run 1 receiver
connector_test_2 @ #if

\ Common initialisation
	: setup
		"Doing setup" log
		\ Param stack alloc
		param_st_alloc
		\ Pub/sub init
		' sdr:do_registrations fr:pubsub_init
		"Setup complete" log
	;
	
	: testdata
		{
			"display-width": 0,
			"display-height": 0,
			"freq": 7150000,
			"mode": ` sdr:CH_LSB ` ,
			"filter": ` sdr:CH_2K4 ` ,
			"agc": ` sdr:CH_AGC_MED ` ,
			"attn": ` sdr:ATTN_NONE ` ,
			"hf-preamp": ` sdr:PRE_OFF ` ,
			"6m-preamp": ` sdr:PRE_OFF ` ,
			"audio-gain": 50
		} ;
				
	\ Runs a basic script to start radio with one receiver on the dafault audio route
	: basic_script	SED: --
		\ in: 	none
		\ out:	none
		sdr:conn_discover "Discover: " . . cr
		sdr:conn_set_default_route "Route: " . . cr
		sdr:conn_start_server "Server start: " . . cr
		0 sdr:conn_start_radio "Radio start: " . . cr
		
		\ Toggle some functions using direct action
		"Direct calls:" log
		2 sleep
		3700000 sdr:conn_r1_freq "Freq 3.7: " . . cr
		2 sleep
		"AM" sdr:mode_for_name sdr:conn_r1_mode "Mode AM: " . . cr
		2 sleep
		0 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 6.1KHz: " . . cr
		2 sleep
		7180000 sdr:conn_r1_freq "Freq 7.18: " . . cr
		2 sleep
		"LSB" sdr:mode_for_name sdr:conn_r1_mode "Mode LSB: " . . cr
		2 sleep
		2 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 2.7KHz: " . . cr
		2 sleep
		3800000 sdr:conn_r1_freq "Freq 3.8: " . . cr
		2 sleep
		"FM" sdr:mode_for_name sdr:conn_r1_mode "Mode FM: " . . cr
		2 sleep
		5 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 1.0KHz: " . . cr	
		
		\ Repeat using events
		"Event calls:" log
		2 sleep
		sdr:SYS_R1_FREQ testdata fr:pubsub_publish "Freq 7.15: " . . cr
		2 sleep
		sdr:SYS_R1_MODE testdata fr:pubsub_publish "Mode LSB: " . . cr
		2 sleep
		sdr:SYS_R1_FILT testdata fr:pubsub_publish "Filter 2.4KHz: " . . cr
		2 sleep
	;
	
	\ Run one test iteration
	: runtest
		cr cr "Run test" log
		t:getq false q:throwing drop
		"TEST_TASK" t:name!
		t:curtask "TEST_TASK" fr:gs_reg!
		\ Do common setup
		setup	
		\ Initialise and do SOD etc
		"Initialising" log
		sdr:conn_init
		"Done initialise" log
		\ Run basic tests
		basic_script
		"Done basic tests" log
		sdr:conn_term 
		"Connector_TASK" fr:gs_wait_single_task 
		fr:pubsub_term
		"P/S_TASK" fr:gs_wait_single_task 
		"TEST_TASK exiting..." log
		1 sleep
	;

	\ Test sequence
	"MAIN_TASK" t:name!
	' runtest t:task
	\ Wait for main task to terminate
	t:wait
	2 sleep
	bye
#then
	