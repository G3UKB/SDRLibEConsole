(* 
	connector.8th
 
  Client connector to SDRLibEConnector server
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

needs stack/3drop

\ ========================================
\ Testing only
false var, connector_test_1
false var, connector_test_2
connector_test_1 @ #if

	\ includes
	"../framework/param_st.8th" f:include
	"../framework/gen_server.8th" f:include
	"../framework/struct_manip.8th" f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
	"../common/radio_defs.8th" f:include
	"../framework/pub_sub.8th"  f:include

	\ needs debug/sed
	\ true SED-CHECK
	\ false log-async
	
	\ Test cases simulation words start
	\ Overwrite words that are needed for simulation testing 
	: net:sendto	\ net ai buf flags -- net #sent
		drop s:len nip nip ;	\ Good case
		\ drop 10 nip nip ;		\ Bad case

	: net:wait	\ net read? msecs -- net f
		2drop true ;								\ Read ready
		\ 1000 / sleep drop false ;	\ Timeout

	: ack_resp \ -- ack
		{"resp":"ACK"} ;

	: audio_resp \ -- audio-resp
		{"outputs": [{},{"api":"someapi" , "name":"somedev"}] } ;

	: net:recvfrom \ net buf flags -- net addr port buf #recv | net null
		\ 2drop "127.0.0.1" 10010 ack_resp >json s:len ; 	\ Good case
		2drop "127.0.0.1" 10010 audio_resp >json s:len ; 	\ Good case
		\ 2drop null ;																		\ Bad case

#then
connector_test_2 @ #if

	\ includes
	"../framework/param_st.8th" f:include
	"../framework/gen_server.8th" f:include
	"../framework/struct_manip.8th" f:include
	"../common/events.8th" f:include
	"../common/registrations.8th" f:include
	"../common/radio_defs.8th" f:include
	"../framework/pub_sub.8th"  f:include

	\ needs debug/sed
	\ true SED-CHECK
	\ false log-async
#then
\ =========================================

(*
	GEN_SERVER application -
	The connector drives the SDRLibE/connector executable via a JSON UDP interface. This enables
	distribution if required and also makes it a managed server which will execute on its own
	once its setup is complete which could be a command line client or a GUI client. It is also
	much more ameanable to multi-language implementation as the interface remains the same on the
	client side rather than an implementation for each language ffi implementation. 
*)

\ Set namespace
ns: sdr

\ ===============================================================================
\ PRIVATE
\ Convention: private words start: 		__conn_
\ 						message handlers start: do_conn_
\							event handlers start: 	__conn_evnt_
\ ===============================================================================

\ Initialisation
\ Create UDP socket
: __conn_create_socket	SED: --
	\ in: 	none
	\ out:	none
	{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket "udp_cmd_sock" t:! ;
	
\ Get command socket
: __conn_cmd_sock@	SED: -- net
	\ in: 	none
	\ out:	s0 - command socket
	"udp_cmd_sock" t:@ ;

\ ===============================================================================
\ Buffers
\ Create response buffer
: __conn_create_resp_buf	SED: --
	\ in: 	none
	\ out:	none
	5000 b:new 0x0 b:fill "b_resp_buffer" t:! ;

\ ----------------------------------	
\ Get response buffer
: __conn_resp_buf@	SED: --
	\ in: 	none
	\ out:	none	
	"b_resp_buffer" t:@ ;
	
\ ===============================================================================
\ Json encoded request messages	
: __conn_push_one_param 	SED: * a -- 
	\ in:		0: m - empty message
	\				1: * - p1
	\ out:	none
	"params" m:@ a:clear rot a:push drop ;

\ ----------------------------------
: __conn_push_two_param 	SED: * * a -- 
	\ in:		0: m - empty message
	\				1: * - p1
	\				2: * - p2
	\ out:	none
	"params" m:@ a:clear rot a:push rot a:push drop ;
	
\ ========================================
\ Simple messages with zero-two parameters, same SED: ... -- s (a Json encoded string)
\ No params
: __conn_poll_msg { "cmd" : "poll" , "params" : [] } >json ;
: __conn_discover_msg { "cmd" : "radio_discover" , "params" : [] } >json ;
: __conn_server_start_msg { "cmd" : "server_start" , "params" : [] } >json ;
: __conn_enum_inputs_msg { "cmd" : "enum_inputs" , "params" : [] } >json ;
: __conn_enum_outputs_msg { "cmd" : "enum_outputs" , "params" : [] } >json ;	
: __conn_radio_stop_msg { "cmd" : "radio_stop" , "params" : [] } >json ;
\ One param
: __conn_radio_start_msg { "cmd" : "radio_start" , "params" : [] } __conn_push_one_param >json ;
: __conn_set_num_rx_msg { "cmd" : "set_num_rx" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_freq_msg { "cmd" : "set_rx1_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_freq_msg { "cmd" : "set_rx2_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_freq_msg { "cmd" : "set_rx3_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_tx_freq_msg { "cmd" : "set_tx_freq" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_mode_msg { "cmd" : "set_rx1_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_mode_msg { "cmd" : "set_rx2_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_mode_msg { "cmd" : "set_rx3_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_tx_mode_msg { "cmd" : "set_tx_mode" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_agc_msg { "cmd" : "set_rx1_agc" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_agc_msg { "cmd" : "set_rx2_agc" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_agc_msg { "cmd" : "set_rx3_agc" , "params" : [] } __conn_push_one_param >json ;
: __conn_r1_gain_msg { "cmd" : "set_rx1_gain" , "params" : [] } __conn_push_one_param >json ;
: __conn_r2_gain_msg { "cmd" : "set_rx2_gain" , "params" : [] } __conn_push_one_param >json ;
: __conn_r3_gain_msg { "cmd" : "set_rx3_gain" , "params" : [] } __conn_push_one_param >json ;
: __conn_hf_pre_msg { "cmd" : "set_hf_pre" , "params" : [] } __conn_push_one_param >json ;
: __conn_attn_msg { "cmd" : "set_attn" , "params" : [] } __conn_push_one_param >json ;
: __conn_disp_width_msg { "cmd" : "set_display_width" , "params" : [] } __conn_push_one_param >json ;
: __conn_disp_period_msg { "cmd" : "set_disp_period" , "params" : [] } __conn_push_one_param >json ;
\ Two params
: __conn_r1_filt_msg { "cmd" : "set_rx1_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_r2_filt_msg { "cmd" : "set_rx2_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_r3_filt_msg { "cmd" : "set_rx3_filter" , "params" : [] } __conn_push_two_param >json ;
: __conn_tx_filt_msg { "cmd" : "set_tx_filter" , "params" : [] } __conn_push_two_param >json ;


\ Complex messages
\ ----------------------------------	
: __conn_default_route_msg	SED: s s -- s
	\ in:		0: s - audio api i.e. "MME"
	\				1: s - audio device name string
	\ out:	0: s - json encoded default route message
	>r >r { "cmd" : "set_audio_route" , "params" : [1, "LOCAL", 1, "", "", "BOTH"] }
	"params" m:@ 3 r> a:! 4 r> a:! drop >json ;

\ ----------------------------------	
: __conn_audio_route_msg	SED: a -- s
	\ in:		0: a - [source, rx, dev,ch]
	\ out:	0: s - json encoded default route message
	>r { "cmd" : "set_audio_route" , "params" : [1] }
	"params" m:@ 
	r@ 0 a:@ nip s:uc a:push
	r@ 1 a:@ nip >n a:push
	r@ 2 a:@ nip ":" s:/ 0 a:@ nip a:push
	r@ 2 a:@ nip ":" s:/ 2 a:@ nip a:push
	r> 3 a:@ nip s:uc a:push drop
	>json ;
	
\ ----------------------------------		
: __conn_disp_state_msg SED: T T T -- s
	{ "cmd" : "set_disp_state" , "params" : [] }
	"params" m:@ rot a:push rot a:push rot a:push drop >json ;

\ ===============================================================================
\ Net

\ ========================================
\ Address management
\ Return the command port
: __conn_cmd_port	SED: -- n
	\ in: 	none
	\ out:	s0 - cmd port
	10010 ;

\ ----------------------------------	
\ Return the display data receiver 1 port	
: __conn_data_1_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 1 port
	10011 ;

\ ----------------------------------	
\ Return the display data receiver 2 port
: __conn_data_2_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 2 port
	10012 ;

\ ----------------------------------	
\ Return the display data receiver 3 port
: __conn_data_3_port	SED: -- n
	\ in: 	none
	\ out:	s0 - display data receiver 3 port
	10013 ;
	
\ ----------------------------------	
\ Return the command address info
: __conn_cmd_addr		SED: -- X
	\ in: 	none
	\ out:	s0 - cmd address info
	"127.0.0.1" __conn_cmd_port net:getaddrinfo ;
	
\ ----------------------------------	
\ Return the display data receiver 1 address info	
: __conn_data_1_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 1 address info
	"127.0.0.1" __conn_data_1_port net:getaddrinfo ;

\ ----------------------------------	
\ Return the display data receiver 2 address info		
: __conn_data_2_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 2 address info
	"127.0.0.1" __conn_data_2_port net:getaddrinfo ;

\ ----------------------------------	
\ Return the display data receiver 3 address info	
: __conn_data_3_addr	SED: -- X
	\ in: 	none
	\ out:	s0 - Data 3 address info
	"127.0.0.1" __conn_data_3_port net:getaddrinfo ;

\ ========================================
\ Message send/receive

\ Send given command
: __conn_send_cmd_msg	SED: s --
	\ in: 	so - json encoded message string
	\ out:	s0 - none
	s:len >r
	__conn_cmd_sock@ __conn_cmd_addr rot 0 net:sendto nip
	r> n:= not if "Short send!" log then ;

\ ----------------------------------	
\ Wait for read data available from cmd socket
: __conn_net_wait_recv_cmd	SED:  -- net T
	\ in: 	none
	\ out:	s0 - true if wait successful
	\				s1 - the target socket
	__conn_cmd_sock@ true 5000 net:wait ;

\ ----------------------------------	
\ Receive data from the given socket
: __conn_recv_from	SED:  net -- m T
	\ in: 	0: s - socket
	\ out:	0: T - true if response received
	\				1: m - the response structure (map in this case)
	\ pre: 	read data ready condition true
	\ SED in >= 19.02:  \ net buf flags -- net X buf #recv | net null
	__conn_resp_buf@ 0 net:recvfrom null? if 
		2drop "Error in read from device!" r@ if throw else log {"resp":"NAK"} then
	else
		\ 19.01
		\ drop nip nip nip json>
		\ 19.02
		drop nip nip json>
	then ;

\ ----------------------------------			
\ Wait for and read cmd response
: __conn_wait_resp_with_timeout	SED: T -- m T
	\ in: 	0: T - if true throw on error
	\ out:	0: T - true if response received
	\				1: m - the response structure (map in this case)
	>r __conn_net_wait_recv_cmd if
		__conn_recv_from
	else
		"Timeout waiting for response from device!" r@ if throw else log drop {"resp":"NAK"} then
	then rdrop ;
	
\ ===============================================================================
\ Protocol words
\ Return the audio info for all output devices
: __conn_get_audio_output_info	SED: -- m T
	\ in: 	none
	\ out:	s0 - true if successful
	\ out:	s1 - the audio info map
	__conn_enum_outputs_msg __conn_send_cmd_msg false __conn_wait_resp_with_timeout ;

\ ----------------------------------	
\ Return the default route audio parameters
: __conn_get_default_route	SED:  -- s s
	\ in: 	none
	\ out:	s0 - the audio api
	\				s1 - the audio device
	__conn_get_audio_output_info
	\ Return api and dev for the default device
	\ Note, we should select for this aka gui interface
	"outputs" m:@ nip 1 a:@ nip
	"api" m:@ swap "name" m:@ nip ;

\ ========================================
\ Message handlers
\ ========================================

\ ========================================
\ General management
\ Initialise the connector at task level
: do_conn_init	SED: a --
	\ in: 	message
	\ out:	none
	drop 
	__conn_create_socket 
	__conn_create_resp_buf ;

\ ----------------------------------
\ Run SOD
: do_conn_start_of_day	SED: a --
	\ in: 	message
	\ out:	none
	drop ;

\ ----------------------------------
\ Close the app model at task level
: do_conn_close	SED: m --
	\ in: 	message
	\ out:	none
	drop ;

\ ========================================
\ Do response
: __con_do_response	SED: -- 
	__conn_wait_resp_with_timeout
	fr:response! ;

\ ----------------------------------
\ Do exchange
: __con_do_exchange	SED: T m --
	\ in: 	0: m - message to send	
	\				1: T - if true then throw on error
	\ out: 	none
	__conn_send_cmd_msg __con_do_response ;

\ ========================================
\ Poll - is there anybody there
: do_conn_poll	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_poll_msg
	false swap __conn_send_cmd_msg
	
	\ SED in >= 19.02:  \ net buf flags -- net X buf #recv | net null
	__conn_cmd_sock@ __conn_resp_buf@ 0 net:recvfrom null? if
		\ No server running or communications problem
		"SDRLibE server is not running or cannot be contacted!" log
		3drop {"resp" : "NAK"}
	else
		\ Got a response
		\ 19.01
		\ drop json> >r 2drop 2drop r>
		\ 19.02
		drop json> >r 2drop drop r>
	then
	fr:response! ;

\ ========================================
\ Initial setup functions
\ Set number of receivers
: do_conn_set_num_rx	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\				1: n - num rx
	\ out: 	q: * - "Timeout" or response data
	swap __conn_set_num_rx_msg false swap __con_do_exchange ;

\ ========================================
\ Audio functions

\ Set a default route for RX1 to Speaker output both channels
: do_conn_set_default_route	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_get_default_route __conn_default_route_msg false swap __con_do_exchange ;

\ ----------------------------------	
\ Set new route
: do_conn_set_audio_route	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\				1: a - [source, rx, dev,ch] 
	\ out: 	q: * - "Timeout" or response data
	
	swap "Set audio route: " . dup . cr
	__conn_audio_route_msg false swap __con_do_exchange ;
	
\ ----------------------------------	
: do_conn_enum_audio_inputs	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_enum_inputs_msg false swap __con_do_exchange ;
	
\ ----------------------------------	
: do_conn_enum_audio_outputs	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_enum_outputs_msg false swap __con_do_exchange ;
	
\ ========================================
\ Basic radio functions
\ Execute discover protocol
: do_conn_discover	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_discover_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Start the server 
: do_conn_start_server	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_server_start_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Start the radio
: do_conn_start_radio	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\				1: T - true if start WBS
	\ out: 	q: * - "Timeout" or response data
	swap __conn_radio_start_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Stop the radio
: do_conn_stop_radio	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\ out: 	q: * - "Timeout" or response data
	__conn_radio_stop_msg false swap __con_do_exchange ;

\ ========================================
\ Receiver functions

\ ========================================
\ FREQUENCY

\ Set R1 frequency
: do_conn_r1_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_freq_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Set R2 frequency
: do_conn_r2_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_freq_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Set R3 frequency
: do_conn_r3_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_freq_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set TX frequency
: do_conn_tx_freq	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - TX freq in Hz
	\ out: 	q: * - "Timeout" or response data
	swap __conn_tx_freq_msg false swap __con_do_exchange ;

\ ========================================
\ MODES

\ ----------------------------------
\ Set R1 mode
: do_conn_r1_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_mode_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set R2 mode
: do_conn_r2_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_mode_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set R3 mode
: do_conn_r3_mode	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 mode id
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_mode_msg false swap __con_do_exchange ;

\ ========================================
\ FILTERS

\ Set R1 filter
: do_conn_r1_filter	SED: a --
	a:open
	\ in: 	0: s - sender (task name)
	\				1: n - R1 filter high
	\				2: n - R1 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot __conn_r1_filt_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set R2 filter
: do_conn_r2_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 filter high
	\				2: s - R2 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot __conn_r2_filt_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set R3 filter
: do_conn_r3_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 filter high
	\				2: s - R3 filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot __conn_r3_filt_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set TX filter
: do_conn_tx_filter	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - TX filter high
	\				2: s - TX filter low
	\ out: 	q: * - "Timeout" or response data
	rot rot  __conn_tx_filt_msg false swap __con_do_exchange ;

\ ========================================
\ AGC
\ Set R1 AGC mode
: do_conn_r1_agc	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 AGC mode
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_agc_msg false swap __con_do_exchange ;

\ ----------------------------------
: do_conn_r2_agc	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 AGC mode
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_agc_msg false swap __con_do_exchange ;
	
\ ----------------------------------
: do_conn_r3_agc	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 AGC mode
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_agc_msg false swap __con_do_exchange ;	

\ ========================================
\ Audio Gain
\ Set R1 AGC mode
: do_conn_r1_gain	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R1 AF gain
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r1_gain_msg false swap __con_do_exchange ;

\ ----------------------------------
: do_conn_r2_gain	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R2 AF gain
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r2_gain_msg false swap __con_do_exchange ;
	
\ ----------------------------------
: do_conn_r3_gain	SED: a --
	a:open
	\ in: 	0: n - sender (task name)
	\				1: s - R3 AF gain
	\ out: 	q: * - "Timeout" or response data
	swap __conn_r3_gain_msg false swap __con_do_exchange ;	
	
\ ========================================
\ Display functions

\ ----------------------------------
\ Set display width
: do_conn_disp_width
	a:open
	\ in: 	0: n - sender (task name)
	\				1: n - width in pixels
	\ out: 	q: * - "Timeout" or response data
	swap __conn_disp_width_msg false swap __con_do_exchange ;
	
\ ----------------------------------
\ Set display period
: do_conn_disp_period
	a:open
	\ in: 	0: n - sender (task name)
	\				1: n - period in ms
	\ out: 	q: * - "Timeout" or response data
	swap __conn_disp_period_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Set display state
: do_conn_disp_state
	a:open
	\ in: 	0: n - sender (task name)
	\				1: T - true if enable R1 display
	\				2: T - true if enable R2 display
	\				3: T - true if enable R3 display
	\ out: 	q: * - "Timeout" or response data
	3 pick 3 pick 3 pick __conn_disp_state_msg false swap __con_do_exchange 3drop ;

\ ========================================
\ MISC
\ Set HF Preamp
: do_conn_hf_pre
	a:open
	\ in: 	0: n - sender (task name)
	\				1: T - on/off
	\ out: 	q: * - "Timeout" or response data
	swap __conn_hf_pre_msg false swap __con_do_exchange ;

\ ----------------------------------
\ Set Attenuator
: do_conn_attn
	a:open
	\ in: 	0: n - sender (task name)
	\				1: n - attenuator in dBM
	\ out: 	q: * - "Timeout" or response data
	swap __conn_attn_msg false swap __con_do_exchange ;
	
\ ===============================================================================
\ PUBLIC
\ Public procedural interface, call from any thread
\ ===============================================================================

\ ========================================
\ Basic commands

\ Execute poll
: conn_poll	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_poll rot fr:msg! 
	fr:response@ ;
	
\ ----------------------------------
\ Execute discover protocol
: conn_discover	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_discover rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Start the server 
: conn_start_server	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_start_server rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Start the radio
: conn_start_radio	SED: n -- *
	\ in: 	0: n - 1 if start WBS
	\ out:	0: * - response
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_start_radio rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Stop the radio
: conn_stop_radio	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender 
	"Connector_TASK" ' do_conn_stop_radio rot fr:msg! 
	fr:response@ ;

\ ========================================
\ Initial setup
: conn_set_num_rx	SED: n -- *
	\ in: 	0: n - num rx
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_set_num_rx rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Audio commands

\ Set a default route for RX1 to Speaker output both channels
: conn_set_default_route	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_set_default_route rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ Set a new audio route
: conn_set_audio_route	SED:  a -- *
	\ in: 	0: a - route descriptor
	\ out:	0: * - response	
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_set_audio_route rot fr:msg! 
	fr:response@ ;
	
\ ----------------------------------
\ Enum audio inputs
: conn_enum_audio_inputs	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_enum_audio_inputs rot fr:msg!
	fr:response@ ;

\ ----------------------------------
\ Enum audio outputs
: conn_enum_audio_outputs	SED:  -- *
	\ in: 	none
	\ out:	0: * - response
	a:new fr:+sender
	"Connector_TASK" ' do_conn_enum_audio_outputs rot fr:msg! 
	fr:response@ ;
	
\ ========================================
\ Frequency

\ ----------------------------------
\ Freq change
: conn_r1_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_freq rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_r2_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push  fr:+sender
	"Connector_TASK" ' do_conn_r2_freq rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_r3_freq	SED: n -- *
	\ in: 	0: n - freq in Hz
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push  fr:+sender
	"Connector_TASK" ' do_conn_r3_freq rot fr:msg! 
	fr:response@ ;

\ ========================================
\ Mode

\ ----------------------------------
\ Mode change
: conn_r1_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_mode rot fr:msg!
	fr:response@ ;
	
\ ----------------------------------
: conn_r2_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_mode rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_r3_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_mode rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
: conn_tx_mode	SED: n -- *
	\ in: 	0: n - mode id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_tx_mode rot fr:msg! 
	fr:response@ ;

\ ========================================
\ Filter

\ ----------------------------------
\ Filter change
: conn_r1_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	st_svr_running@ not if 2drop {"resp" : "NAK"} ;; then
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_filter rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_r2_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	st_svr_running@ not if 2drop {"resp" : "NAK"} ;; then
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_filter rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_r3_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	st_svr_running@ not if 2drop {"resp" : "NAK"} ;; then
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_filter rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
: conn_tx_filter	SED: n n -- *
	\ in: 	0: n - filter high
	\				1: n - filter low
	\ out:	0: * - response
	st_svr_running@ not if 2drop {"resp" : "NAK"} ;; then
	a:new swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_tx_filter rot fr:msg! 
	fr:response@ ;

\ ----------------------------------
\ AGC change
: conn_r1_agc	SED: n -- *
	\ in: 	0: n - agc id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_agc rot fr:msg!
	fr:response@ ;
	
\ ----------------------------------
: conn_r2_agc	SED: n -- *
	\ in: 	0: n - agc id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_agc rot fr:msg!
	fr:response@ ;

\ ----------------------------------
: conn_r3_agc	SED: n -- *
	\ in: 	0: n - agc id
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_agc rot fr:msg!
	fr:response@ ;

\ ----------------------------------
\ Audio gain change
: conn_r1_gain	SED: n -- *
	\ in: 	0: n - audio gain
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r1_gain rot fr:msg!
	fr:response@ ;
	
\ ----------------------------------
: conn_r2_gain	SED: n -- *
	\ in: 	0: n - audio gain
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r2_gain rot fr:msg!
	fr:response@ ;

\ ----------------------------------
: conn_r3_gain	SED: n -- *
	\ in: 	0: n - audio gain
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_r3_gain rot fr:msg!
	fr:response@ ;

\ ========================================
\ Displays

\ ----------------------------------	
\ Set the display width
: conn_set_disp_width	SED: n -- *
	\ in: 	0: n - width in pixels
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_disp_width rot fr:msg!
	fr:response@ ;

\ ----------------------------------		
\ Set the display update period
: conn_set_disp_period	SED: n -- *
	\ in: 	0: n - update period in ms
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_disp_period rot fr:msg! 
	fr:response@ ;

\ ----------------------------------	
\ Set the display state
: conn_set_disp_state	SED: T T T -- *
	\ in: 	0: T - true if enable R1 display
	\				1: T - true if enable R2 display
	\				2: T - true if enable R3 display
	\ out:	0: * - response
	st_svr_running@ not if 3drop {"resp" : "NAK"} ;; then
	a:new swap a:push swap a:push swap a:push fr:+sender
	"Connector_TASK" ' do_conn_disp_state rot fr:msg! 
	fr:response@ ;	

\ ========================================
\ Misc
: conn_hf_pre	SED: n -- *
	\ in: 	0: T - on/off
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_hf_pre rot fr:msg!
	fr:response@ ;

\ ----------------------------------
: conn_attn	SED: n -- *
	\ in: 	0: n - attenuator in dBM
	\ out:	0: * - response
	st_svr_running@ not if drop {"resp" : "NAK"} ;; then
	a:new swap a:push fr:+sender
	"Connector_TASK" ' do_conn_attn rot fr:msg!
	fr:response@ ;
	
\ ===============================================================================
\ EVENT HANDLERS for Publish/Subscribe system
\ Never call directly, only via pubsub_publish

\ Not implemented subscribe
: __conn_not_implemented	SED: * --
	drop {"resp" : "NAK"} ;

\ ----------------------------------
\ Decode response
: __conn_evnt_resp SED: T s --
	\ in:		0: s - failure message
	\				1: T - false if failure
	\ out: 	none
	\ Throws exception on error
	swap null? if
		2drop "Warning - bad response from connector call!" log
	else
		not if
			"Server error from [" swap >s s:+ "]" s:+ log
		else
			drop
		then
	then ;

\ ----------------------------------
\ Initial settings
: __conn_evnt_set_num_rx SED: n --
\ "__conn_evnt_set_num_rx" log
	conn_set_num_rx "num rx" __conn_evnt_resp ;

\ ----------------------------------
\ Frequency update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_freq SED: m --
	\ "__conn_evnt_r1_freq" log
	"freq" m:@ nip conn_r1_freq "r1 frequency" __conn_evnt_resp ;
	
: __conn_evnt_r2_freq SED: m --
	\ "__conn_evnt_r2_freq" log
	st_rad_num_rx@ 2 n:< if drop ;; then 
	"freq" m:@ nip conn_r2_freq "r2 frequency" __conn_evnt_resp ;
	
: __conn_evnt_r3_freq SED: m --
	\ "__conn_evnt_r3_freq" log
	st_rad_num_rx@ 3 n:< if drop ;; then 
	"freq" m:@ nip conn_r3_freq "r3 frequency" __conn_evnt_resp ;

\ ----------------------------------
\ Mode update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_mode SED: m --
	\ "__conn_evnt_r1_mode" log
	"mode" m:@ nip conn_r1_mode "r1 mode" __conn_evnt_resp ;
	
: __conn_evnt_r2_mode SED: m --
	\ "__conn_evnt_r2_mode" log
	st_rad_num_rx@ 2 n:< if drop ;; then 
	"mode" m:@ nip conn_r2_mode "r2 mode" __conn_evnt_resp ;
	
: __conn_evnt_r3_mode SED: m --
	\ "__conn_evnt_r3_mode" log
	st_rad_num_rx@ 3 n:< if drop ;; then
	"mode" m:@ nip conn_r3_mode "r3 mode" __conn_evnt_resp ;

\ ----------------------------------
\ Filter update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_filter SED: m --
	\ "__conn_evnt_r1_filter" log
	"filter" m:@ nip
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r1_filter "r1 filter" __conn_evnt_resp ;
	
: __conn_evnt_r2_filter SED: m --
	\ "__conn_evnt_r2_filter" log
	st_rad_num_rx@ 2 n:< if drop ;; then 
	"filter" m:@ nip
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r2_filter "r2 filter" __conn_evnt_resp ;
	
: __conn_evnt_r3_filter SED: m --
	\ "__conn_evnt_r3_filter" log
	st_rad_num_rx@ 3 n:< if drop ;; then
	"filter" m:@ nip
	sdr:filter_lookup 0 a:@ swap 1 a:@ nip 
	conn_r3_filter "r3 filter" __conn_evnt_resp ;

\ ----------------------------------
\ AGC update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_agc SED: m --
	\ "__conn_evnt_r1_agc" log
	"agc" m:@ nip conn_r1_agc "r1 agc" __conn_evnt_resp ;
	
: __conn_evnt_r2_agc SED: m --
	\ "__conn_evnt_r2_agc" log
	st_rad_num_rx@ 2 n:< if drop ;; then 
	"agc" m:@ nip conn_r2_agc "r2 agc" __conn_evnt_resp ;
	
: __conn_evnt_r3_agc SED: m --
	\ "__conn_evnt_r3_agc" log
		st_rad_num_rx@ 3 n:< if drop ;; then 
	"agc" m:@ nip conn_r3_agc "r3 agc" __conn_evnt_resp ;

\ ----------------------------------
\ Audio gain update
\ in:		0: m - map of radio state
\ out: 	none
: __conn_evnt_r1_gain SED: m --
	\ "__conn_evnt_r1_gain" log
	"audio-gain" m:@ nip conn_r1_gain "r1 gain" __conn_evnt_resp ;
	
: __conn_evnt_r2_gain SED: m --
	\ "__conn_evnt_r2_gain" log
	st_rad_num_rx@ 2 n:< if drop ;; then 
	"audio-gain" m:@ nip conn_r2_gain "r2 gain" __conn_evnt_resp ;
	
: __conn_evnt_r3_gain SED: m --
	\ "__conn_evnt_r3_gain" log
	st_rad_num_rx@ 3 n:< if drop ;; then 
	"audio-gain" m:@ nip conn_r3_gain "r3 gain" __conn_evnt_resp ;

\ ----------------------------------
\ Misc update
: __conn_evnt_hf_pre SED: m --
	\ "__conn_evnt_hf_pre" log 
	"hf-pre" m:@ nip conn_hf_pre "hf pre" __conn_evnt_resp ;

\ ----------------------------------
: __conn_evnt_attn SED: m --
	\ "__conn_evnt_attn" log 
	"attn" m:@ nip conn_attn "attn" __conn_evnt_resp ;
	
\ ----------------------------------
\ Display update
: __conn_evnt_disp_width	SED: w --
	\ "__conn_evnt_disp_width" log
	conn_set_disp_width "disp_width" __conn_evnt_resp ;

\ ----------------------------------
\ Audio route update
: __conn_evnt_set_audio_route	SED: a --
	conn_set_audio_route "audio_route" __conn_evnt_resp ;
	
: __conn_evnt_set_audio_routes	SED: a --
	\ "__conn_evnt_audio_route" log
	' __conn_evnt_set_audio_route a:each ;
	
\ ===============================================================================
\ INITIALISATION and TERMINATION

\ Subscribe to system events that need to be forwarded to the server
: __conn_subscribe	SED: --
	SYS_NUM_RX ' __conn_evnt_set_num_rx fr:pubsub_subscribe
	SYS_R1_FREQ ' __conn_evnt_r1_freq fr:pubsub_subscribe
	SYS_R2_FREQ ' __conn_evnt_r2_freq fr:pubsub_subscribe
	SYS_R3_FREQ ' __conn_evnt_r3_freq fr:pubsub_subscribe
	SYS_R1_MODE ' __conn_evnt_r1_mode fr:pubsub_subscribe
	SYS_R2_MODE ' __conn_evnt_r2_mode fr:pubsub_subscribe
	SYS_R3_MODE ' __conn_evnt_r3_mode fr:pubsub_subscribe
	SYS_R1_FILT ' __conn_evnt_r1_filter fr:pubsub_subscribe
	SYS_R2_FILT ' __conn_evnt_r2_filter fr:pubsub_subscribe
	SYS_R3_FILT ' __conn_evnt_r3_filter fr:pubsub_subscribe
	SYS_R1_AGC ' __conn_evnt_r1_agc fr:pubsub_subscribe
	SYS_R2_AGC ' __conn_evnt_r2_agc fr:pubsub_subscribe
	SYS_R3_AGC ' __conn_evnt_r3_agc fr:pubsub_subscribe
	SYS_R_ATTN ' __conn_evnt_attn fr:pubsub_subscribe
	SYS_R_HF_PRE ' __conn_evnt_hf_pre fr:pubsub_subscribe
	\ SYS_R_6M_PRE ' __conn_not_implemented fr:pubsub_subscribe
	SYS_R1_AFGAIN ' __conn_evnt_r1_gain fr:pubsub_subscribe
	SYS_R2_AFGAIN ' __conn_evnt_r2_gain fr:pubsub_subscribe
	SYS_R3_AFGAIN ' __conn_evnt_r3_gain fr:pubsub_subscribe
	\ SYS_MOX ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_DUPLEX ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_RFGAIN ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_MICGAIN ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_TX_FREQ ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_TX_MODE ' __conn_not_implemented fr:pubsub_subscribe
	\ SYS_TX_FILT ' __conn_not_implemented fr:pubsub_subscribe
	SYS_DISP_WIDTH ' __conn_evnt_disp_width fr:pubsub_subscribe
	SYS_AUDIO_ROUTE ' __conn_evnt_set_audio_routes fr:pubsub_subscribe
	\ SYS_RUN_STATE ' __conn_not_implemented fr:pubsub_subscribe 
;
	
\ ----------------------------------
\ Module initialisation
: conn_init	SED: --
	\ in: 	none
	\ out:	none
	\ Do subscription
	__conn_subscribe
	\ Create the connector gen-server
	"Connector_TASK" t:curtask 2 ' fr:gen_server t:task-n -1 sleep drop
	\ Ask the connector to initialise itself
	"Connector_TASK" ' do_conn_init a:new fr:msg!
	"Connector initialised sent" log
	"Connector_TASK" ' do_conn_start_of_day a:new fr:msg! ;

\ ----------------------------------
\ Module close
: conn_term	SED: --
	\ in: 	none
	\ out:	none
	\ Tidy close the connector
	"Connector_TASK" ' do_conn_close a:new fr:msg!
	0.5 sleep
	\ Ask the connector to exit
	"Connector_TASK" ' fr:gs_do_term a:new fr:msg! ;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

\ ========================================
\ Test 1 - run all words with simulation.
connector_test_1 @ #if

	\ The test cases exercise each word on all paths and use the SED checker to establish
	\ correct stack behaviour. Some words may use words that require external calls and possibly
	\ expect external data. These are simulated by an overwrite of those words and the simulated
	\ word then behaves as closely as possible to the actual word. These words are at the beginning
	\ of the module as they need to be compiled first.	
	: test_cases
		\ Basic words with no dependencies
		resp_buffer "Buffer: " . b:len . drop cr
		discover_msg "Discover: " . . cr
		server_start_msg "Server start: " . . cr
		0 radio_start_msg "Radio start: " . . cr
		enum_outputs_msg "Enum outputs: " . . cr
		"some api" "some_dev" default_route_msg "Default route: " . . cr
		get_default_route "Get default route: " . cr
		cmd_port "Cmd port: " . . cr
		data_1_port "Data_1_port port: " . . cr
		data_2_port "Data_2_port port: " . . cr
		data_3_port "Data_3_port port: " . . cr
		cmd_addr "Cmd addr: " . . cr
		data_1_addr "Data_1_addr addr: " . . cr
		data_2_addr "Data_2_addr addr: " . . cr
		data_3_addr "Data_3_addr addr: " . . cr
		\ Words with dependencies
		discover_msg send_cmd_msg "Send discover message" . cr
		net_wait_recv_cmd "Wait for read data: " . . cr drop
		cmd_sock recv_from "Read: " . . " Data: " . . cr
		wait_resp_with_timeout "Response: " . . " Data: " . . cr ;
		
	cr cr "Running test cases..." . cr cr
	test_cases
	"Done test cases" . cr
	bye
#then

\ ========================================
\ Test 2 - basic script to run 1 receiver
connector_test_2 @ #if

\ Common initialisation
	: setup
		"Doing setup" log
		\ Param stack alloc
		param_st_alloc
		\ Pub/sub init
		' sdr:do_registrations fr:pubsub_init
		"Setup complete" log
	;
	
	: testdata
		{
			"display-width": 0,
			"display-height": 0,
			"freq": 7150000,
			"mode": ` sdr:CH_LSB ` ,
			"filter": ` sdr:CH_2K4 ` ,
			"agc": ` sdr:CH_AGC_MED ` ,
			"attn": ` sdr:ATTN_NONE ` ,
			"hf-preamp": ` sdr:PRE_OFF ` ,
			"6m-preamp": ` sdr:PRE_OFF ` ,
			"audio-gain": 50
		} ;
				
	\ Runs a basic script to start radio with one receiver on the dafault audio route
	: basic_script	SED: --
		\ in: 	none
		\ out:	none
		sdr:conn_discover "Discover: " . . cr
		sdr:conn_set_default_route "Route: " . . cr
		sdr:conn_start_server "Server start: " . . cr
		0 sdr:conn_start_radio "Radio start: " . . cr
		
		\ Toggle some functions using direct action
		"Direct calls:" log
		2 sleep
		3700000 sdr:conn_r1_freq "Freq 3.7: " . . cr
		2 sleep
		"AM" sdr:mode_for_name sdr:conn_r1_mode "Mode AM: " . . cr
		2 sleep
		0 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 6.1KHz: " . . cr
		2 sleep
		7180000 sdr:conn_r1_freq "Freq 7.18: " . . cr
		2 sleep
		"LSB" sdr:mode_for_name sdr:conn_r1_mode "Mode LSB: " . . cr
		2 sleep
		2 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 2.7KHz: " . . cr
		2 sleep
		3800000 sdr:conn_r1_freq "Freq 3.8: " . . cr
		2 sleep
		"FM" sdr:mode_for_name sdr:conn_r1_mode "Mode FM: " . . cr
		2 sleep
		5 sdr:filter_lookup 0 a:@ swap 1 a:@ nip sdr:conn_r1_filter "Filter 1.0KHz: " . . cr	
		
		\ Repeat using events
		"Event calls:" log
		2 sleep
		sdr:SYS_R1_FREQ testdata fr:pubsub_publish "Freq 7.15: " . . cr
		2 sleep
		sdr:SYS_R1_MODE testdata fr:pubsub_publish "Mode LSB: " . . cr
		2 sleep
		sdr:SYS_R1_FILT testdata fr:pubsub_publish "Filter 2.4KHz: " . . cr
		2 sleep
	;
	
	\ Run one test iteration
	: runtest
		cr cr "Run test" log
		t:getq false q:throwing drop
		"TEST_TASK" t:name!
		t:curtask "TEST_TASK" fr:gs_reg!
		\ Do common setup
		setup	
		\ Initialise and do SOD etc
		"Initialising" log
		sdr:conn_init
		"Done initialise" log
		1 sleep
		sdr:conn_poll if
			1 sleep
			\ Run basic tests
			basic_script
			"Done basic tests" log
			sdr:conn_term 
			"Connector_TASK" fr:gs_wait_single_task 
			fr:pubsub_term
			"P/S_TASK" fr:gs_wait_single_task 
			"TEST_TASK exiting..." log
			1 sleep
		then
	;

	\ Test sequence
	"MAIN_TASK" t:name!
	' runtest t:task
	\ Wait for main task to terminate
	t:wait
	2 sleep
	bye
#then
	