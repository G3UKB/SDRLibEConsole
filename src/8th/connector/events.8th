(* 
	events.8th
 
  SDRLibEConnector server display event handler
 
 Copyright C 2018 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
*)

(*
	This is the server event system task[s]. It is not a gen-server as the messaging overhead is too high
	
	Display dats for panadapter/waterfall and WBS is high volume with a frequency of no less
	than 200ms, otherwise the display will be visibly jerky.
	In order to maintain this data rate we cannot afford to transition the data through the normal
	channels which involves potentially multiply clones and several tasks aka gen-server management. 
	The connection is therefore direct...
	
	We tell the server what data is required i.e r1/r2/r3/wbs and the required frequency of that data. The
	server will then send that data on separate UDP channels for each display at the requested frequency. 
	We start a reader thread for each display. These threads are enabled/disabled by the svr_evnt_set_disp_state
	call. When a reader thread is active data received is shipped directly to the display instance data buffer 
	[disp_common.8th]. Calls are then made to the builder to make the arrays for subsequent rendering. 
	The builders are passed the display instance data id.
	
	The builders can operate on any thread as they do not render, that is handled by disp_renderer.8th which operates
	off a GUI timer so the render can be at a different frequency to the data collection if required. Rendering
	of course must be on the main thread.
*)

\ Set namespace
ns: sdr

\ ===============================================================================
\ PRIVATE
\ Convention: private words start: 		__svr_evnt_
\ ===============================================================================

\ Initialisation
: __svr_evnt_host	"localhost" ;
: __svr_evnt_d1_port 10011 ;
: __svr_evnt_d2_port 10012 ;
: __svr_evnt_d3_port 10013 ;
	
\ Create UDP socket
: __svr_evnt_create_d1_sock
	{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket dup "udp_d1_evnt_sock" t:!
	__svr_evnt_host __svr_evnt_d1_port net:getaddrinfo swap net:bind ;

: __svr_evnt_create_d2_sock
	{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket dup "udp_d2_evnt_sock" t:!
	__svr_evnt_host __svr_evnt_d2_port net:getaddrinfo swap net:bind ;
	
: __svr_evnt_create_d3_sock
	{ "domain" : ` net:INET4 ` , "type" : ` net:DGRAM ` , "proto" : ` net:PROTO_UDP ` } net:socket dup "udp_d3_evnt_sock" t:!
	__svr_evnt_host __svr_evnt_d3_port net:getaddrinfo swap net:bind ;
	
\ ----------------------------------	
\ Get command socket
: __svr_evnt_d1_sock@	"udp_d1_evnt_sock" t:@ ;
: __svr_evnt_d2_sock@	"udp_d2_evnt_sock" t:@ ;
: __svr_evnt_d3_sock@	"udp_d3_evnt_sock" t:@ ;

\ ========================================
\ Reader Task
\ ========================================

\ Read event data while enabled and not terminated
\ Write event data to the data-buffer in instance data
: __svr_evnt_reader	SED: net s --
	\ in: 	0: s - reader instance
	\				1: net - socket
	\ out:	none
	
	\ ----------------------------------
	\ Task initialisation
	\ Save the task instance
	dup "reader_inst" t:!
	\ Register the task instance
	"-TASK" s:+ dup t:name!
	t:curtask swap fr:gs_reg!
	\ Save socket
	"reader_skt" t:!
	\ Make sure the q does not throw
	t:getq false q:throwing drop
	
	\ ----------------------------------
	\ Wait for work
	repeat
		"Waiting for work" . cr
		-1 t:q-wait
		"Off wait" . cr
		t:pop null? not if
			break
		else
			drop
		then
	again
	
	"Starting run section" . cr
	\ ----------------------------------
	\ have we been told to run?
	"run" s:= if
		"Running" . cr
		\ Yes, so enter the read loop
		repeat
			\ Check for termination at top of loop
			t:qlen 0 n:> if 
				t:pop null? not if
					"term" s:= if break then
				then
			else
				drop
				\ See if we have data
				"Waiting data" . cr
				"reader_skt" t:@ true 500 net:wait if
					"Read data?" . cr
					\ Socket says yes
					"reader_inst" t:@ disp_buf_ref 0 net:recvfrom null? not if
						\ Read something
						"Received:" swap s:+ log 4drop
						\ Call display builders to process the data
					then
				then
			then	
		again
	then
	t:name@ " exiting..." s:+ log
;

\ ===============================================================================
\ PUBLIC
\ ===============================================================================

\ ========================================
\ General management
\ Initialise the sockets
: svr_evnt_init	SED:  --
	\ in: 	none
	\ out:	none
	\ Create sockets
	__svr_evnt_create_d1_sock
	__svr_evnt_create_d2_sock
	\ __svr_evnt_create_d3_sock
	\ Start tasks
	__svr_evnt_d1_sock@ "DISP-R1" 2 ' __svr_evnt_reader t:task-n
	__svr_evnt_d2_sock@ "DISP-R2" 2 ' __svr_evnt_reader t:task-n
	__svr_evnt_d3_sock@ "DISP-R3" 2 ' __svr_evnt_reader t:task-n 
	\ These are started by a transient task and must remain on-stack
	\ for now else they will be collected. 
;

\ ----------------------------------	
\ Set the display period in ms
: svr_evnt_set_disp_period	SED: n -- T
	\ in: 	0: n - update period in ms
	\ out:	0: T - true if success
	conn_set_disp_period 
	"resp" m:@ "ACK" s:= nip if true else false then ;

\ ----------------------------------
\ Enable/disable displays
: svr_evnt_set_disp_state	SED: T T T -- T
	\ in: 	0: T - true if enable R1 display
	\				1: T - true if enable R2 display
	\				2: T - true if enable R3 display
	\ out:	0: T - true if success
	2 pick 2 pick 2 pick conn_set_disp_state
	"resp" m:@ "ACK" s:= nip if 
		\ Enable the corresponding reader tasks
		if "DISP-R1-TASK" fr:__gs_reg@ dup "run" t:push t:q-notify then
		if "DISP-R2-TASK" fr:__gs_reg@ dup "run" t:push t:q-notify then
		if "DISP-R3-TASK" fr:__gs_reg@ dup "run" t:push t:q-notify then
		true 
	else 
		false 
	then ;

\ ----------------------------------
\ Terminate displays
: svr_evnt_term	SED:  -- 
	"DISP-R1-TASK" fr:__gs_reg@ dup "term" t:push t:q-notify
	"DISP-R2-TASK" fr:__gs_reg@ dup "term" t:push t:q-notify
	"DISP-R3-TASK" fr:__gs_reg@ dup "term" t:push t:q-notify ;

\ ========================================
\ Reset namespace
ns: user